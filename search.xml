<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>华为云</title>
      <link href="/2019/12/08/%E5%8D%8E%E4%B8%BA%E4%BA%91/"/>
      <url>/2019/12/08/%E5%8D%8E%E4%B8%BA%E4%BA%91/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="华为云Login-2020"><a href="#华为云Login-2020" class="headerlink" title="华为云Login 2020"></a>华为云Login 2020</h2><p>​    <strong>起片：</strong></p><p>​        12月7号有幸参加华为云的 DevRun Summit Login 2020 这个活动，其实更多的是令我意想不到的人和活动方的慷慨。</p><h4 id="信息无障碍——用热爱打开人生另一道门"><a href="#信息无障碍——用热爱打开人生另一道门" class="headerlink" title="信息无障碍——用热爱打开人生另一道门"></a><strong>信息无障碍——用热爱打开人生另一道门</strong></h4><p><img src="http://www.zai1999.club/img/suiyi/hw-1r.jpg" alt data-src="http://www.zai1999.club/img/suiyi/hw-1r.jpg" class="lazyload"><br>难以想象的是这位工程师竟然有视力障碍，特别令我尊敬的一点，对于车祸后的这样的人生没有选择放弃，利用有声的资料和idea插件自学了编程，有幸的接触了信息无障碍，并加入了深圳信息无障碍公司，利用自己所学帮助身体有障碍或不能快速获取信息的人。<br><img src="http://www.zai1999.club/img/suiyi/hw-tu1.jpg" alt data-src="http://www.zai1999.club/img/suiyi/hw-tu1.jpg" class="lazyload"><br><img src="http://www.zai1999.club/img/suiyi/hw-tu2.jpg" alt data-src="http://www.zai1999.club/img/suiyi/hw-tu2.jpg" class="lazyload"><br>​        以上介绍的是：高级信息无障碍工程师 | 吴益明</p><h4 id="一个98年女CTO的自我修炼之路"><a href="#一个98年女CTO的自我修炼之路" class="headerlink" title="一个98年女CTO的自我修炼之路"></a><strong>一个98年女CTO的自我修炼之路</strong></h4><p><img src="http://www.zai1999.club/img/suiyi/hw-2r.jpg" alt data-src="http://www.zai1999.club/img/suiyi/hw-2r.jpg" class="lazyload"><br>是不是觉得令人不可思议，98年和我一样大的女孩已经作为一家公司的CTO了，“技术限制了你？不，想象力才是！”我很认同候煜欣的这段话，曾经都说中国是”山寨之国”,只会从别的地方copy并轻改造，很多人觉得我们没有创新没有想象力，其实并不是的，没有创新的话那双卡双待怎么来的，没有想象力的话那奇奇怪怪的山寨机从何而来，前几年很火的是培养孩子的想象力和创造力，这几年也逐渐呈现。（跑偏了~，哈哈哈）候煜欣也是自学代码，爱上代码，并自主创业，从下面做到CTO，她也用了更新颖的方式去布置任务，高效完成，年轻的程序员可能接受能力好一些，但一些老程序员可能会不太接受，就像每年的新框架或者新产品老的不去接收，小的去学习接收，一批一批的就像割麦子一样被裁下（并不是说老程序员不好，老程序员也是很厉害的值得我们去学习，像一些底层逻辑，全是一代一代堆起来学习的）<br><img src="http://www.zai1999.club/img/suiyi/hw-tu3.jpg" alt data-src="http://www.zai1999.club/img/suiyi/hw-tu3.jpg" class="lazyload"><br><img src="http://www.zai1999.club/img/suiyi/hw-tu4.jpg" alt data-src="http://www.zai1999.club/img/suiyi/hw-tu4.jpg" class="lazyload"><br><img src="http://www.zai1999.club/img/suiyi/hw-tu5.jpg" alt data-src="http://www.zai1999.club/img/suiyi/hw-tu5.jpg" class="lazyload"><br><img src="http://www.zai1999.club/img/suiyi/hw-tu6.png" alt data-src="http://www.zai1999.club/img/suiyi/hw-tu6.png" class="lazyload"><br>​        以上介绍是：悉之教育CTO | 候煜欣</p><h4 id="从初心到梦想——一个00后开发者"><a href="#从初心到梦想——一个00后开发者" class="headerlink" title="从初心到梦想——一个00后开发者"></a><strong>从初心到梦想——一个00后开发者</strong></h4><p><img src="http://www.zai1999.club/img/suiyi/hw-3r.jpg" alt data-src="http://www.zai1999.club/img/suiyi/hw-3r.jpg" class="lazyload"><br>12岁的孙晟哲是西瓜创客的一名学员，（其实我也是才知道西瓜创客，在学校时学编程的时候就想着25岁开自己的工作室，专门做少儿编程类，没想到。。。）</p><p>他自己制作的小游戏供同学们玩，自己也有一个基金会，名字是小财神基金迄今为止帮助了200人完成学业（非常值得我去学习），也用华为AI制作了卡路里计算器，未来这位小朋友也会做糖分计算器供有糖尿病患者使用。（已经竖起666个的大拇指了）<br><img src="http://www.zai1999.club/img/suiyi/hw-tu7.jpg" alt data-src="http://www.zai1999.club/img/suiyi/hw-tu7.jpg" class="lazyload"><br><img src="http://www.zai1999.club/img/suiyi/hw-tu8.jpg" alt data-src="http://www.zai1999.club/img/suiyi/hw-tu8.jpg" class="lazyload"><br><img src="http://www.zai1999.club/img/suiyi/hw-tu9.jpg" alt data-src="http://www.zai1999.club/img/suiyi/hw-tu9.jpg" class="lazyload"><br>​            以上介绍是：00后开发者 | 孙晟哲</p><p>下面这位，我只能用视频喽去描述这位小哥哥呀<br><img src="http://www.zai1999.club/img/suiyi/hw-4r.jpg" alt data-src="http://www.zai1999.club/img/suiyi/hw-4r.jpg" class="lazyload"><br><a href="https://m.bilibili.com/video/av78362318.html" target="_blank" rel="noopener">这里是视频的全程回顾</a></p><p>这次的会场既学习了，又在努力下获得了第三呀，感谢金主papa的华为耳机！<br>（对了这次的华为专场全是90后哦）<br><img src="http://www.zai1999.club/img/suiyi/hw-hc.jpg" alt data-src="http://www.zai1999.club/img/suiyi/hw-hc.jpg" class="lazyload"><br><img src="http://www.zai1999.club/img/suiyi/hw-qs.jpg" alt data-src="http://www.zai1999.club/img/suiyi/hw-qs.jpg" class="lazyload"><br><img src="http://www.zai1999.club/img/suiyi/hw-hz.jpg" alt data-src="http://www.zai1999.club/img/suiyi/hw-hz.jpg" class="lazyload"><br><strong>哦，对了，之后呢，博主会很少很少的（几乎不写了）去写技术类的文章了，一些原因不去从事这方面的事业了，做起了食材行业，是不是感觉跟所学相差十万八千里，哈哈哈！无论做什么都要尽自己最大努力</strong></p>]]></content>
      
      
      <categories>
          
          <category> 业余 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 华为云 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>学习w快乐</title>
      <link href="/2019/12/03/%E5%AD%A6%E4%B9%A0w%E5%BF%AB%E4%B9%90/"/>
      <url>/2019/12/03/%E5%AD%A6%E4%B9%A0w%E5%BF%AB%E4%B9%90/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="哈佛大学推荐的20个快乐习惯"><a href="#哈佛大学推荐的20个快乐习惯" class="headerlink" title="哈佛大学推荐的20个快乐习惯"></a>哈佛大学推荐的20个快乐习惯</h2><p><strong>01</strong></p><p><strong>Be grateful</strong></p><p><strong>学会感激</strong></p><p><em>Slow down, look around you, and pay attention to the little details in your life – the delicate purple flower on the sidewalk, the beautiful sunset, the hot shower that washes away your long day, and the smile in your partner’s eyes.</em></p><p>让自己变慢脚步，看看你的四周，关注生活中的细微之处：人行道上淡紫色的花，美丽的日落，洗去你一天疲惫的淋浴，伴侣眼中的笑容。</p><p><em>When you have a grateful heart that is appreciative of life’s beautify, wonder and blessings, you’re automatically filled with happiness.</em></p><p>当你的感恩之心能够欣赏生活的美，思考和祝福，你自然就充满了幸福感。</p><p><strong>02</strong></p><p><strong>Choose your friends wisely</strong></p><p><strong>明智地选择自己的朋友</strong></p><p><em>According to Harvard, the most important external factors affecting individual happiness are human relationships. So if you want to be happy, choose to be around people who are optimistic, who appreciate you as you are, and who can make your life richer, bigger, more fun, and more meaningful.</em></p><p>根据哈佛，影响个人幸福最重要的外部因素是人际关系。所以如果你想变得开心的话，要选择和乐观的朋友在一起，他们能欣赏真实的你，让你的生活变得更丰富、快乐、有意义。</p><p><strong>03</strong></p><p><strong>Cultivate compassion</strong></p><p><strong>培养同情心</strong></p><p><em>When we try to step into other people’s shoes and understand a situation from another’s perspective, we’re more likely to handle the situation with compassion, objectivity and effectiveness. There will be less conflicts and more happiness.</em></p><p>当我们代替别人，站在另一个角度看问题，我们更能用同情心，客观和有效地处理问题。生活中就会少一些冲突，多一点快乐。</p><p><strong>04</strong></p><p><strong>Keep learning</strong></p><p><strong>不断学习</strong></p><p><em>Learning keeps us young and dreams keep us alive. When we engage our brains and put them toward productive uses, we’re less likely to dwell on unhappy thoughts and much more likely to feel happy and fulfilled.</em></p><p>学习让我们保持年轻，梦想让我们充满活力。我们运用大脑，进行运作的时候，我们就不大会想不开心的事情，我们会变得更开心和满足。</p><p><strong>05</strong></p><p><strong>Become a problem solver</strong></p><p><strong>学会解决问题</strong></p><p><em>Happy people are problem solvers. When they encounter a challenge in life, they don’t beat themselves up and fall into a depressive state. Instead, they face up to the challenge and channel their energies toward finding creative a solution. By becoming a problem solver, you’ll build up your self-confidence and your ability to accomplish whatever it is you set your mind to – and whatever challenges life throws your way.The result? You’ll have more happiness in your life.</em></p><p>开心的人是会解决问题的人。在生活中遇到挑战的时候，他们不会自虐，然后变得很消沉。他们会直面挑战，调动全身力量寻找解决办法。通过变成一个解决问题的人，你会建立自己的自信心和下决心要的事情和直面挑战的能力。结果是你在生活中将更加拥有更多快乐。</p><p><strong>06</strong></p><p><strong>Do what you love</strong></p><p><strong>做你想做的事情</strong></p><p><em>Since we spend over one-third of our adult life working, loving what we do has a huge impact on our overall happiness. It’s one of life’s greatest blessings to find a line of work that we’re deeply passionate about and that utilizes our greatest gifts. If this is not possible at the moment, then try to find enjoyment and meaning in your current work, or cultivate a hobby that involves doing something you love.</em></p><p>既然我们成人生活的三分之一时间都在工作，那么做我们想做的事对我们的整体幸福感就有很大的影响。做自己最热爱的工作并把天赋发挥最大化，这是人生最大的幸福之一。如果现在不能做你想做的事情，那就试着在你现在的工作中寻找快乐和意义，或者培养一个你喜爱的兴趣。</p><p><strong>07</strong></p><p><strong>Live in the present</strong></p><p><strong>活在当下</strong></p><p><em>When you feel depressed, you’re living in the past. When you feel worried or anxious, you’re living in the future. But when you feel content, happy and peaceful, you’re living in the present.</em></p><p>你感到沮丧，是因为你活在过去。你会感到担忧和焦虑，是因为你活在未来。但是当你感到满足，开心和平和时，你才是活在当下。</p><p><strong>08</strong></p><p><strong>Laugh often</strong></p><p><strong>要经常笑</strong></p><p><em>Laughter is the most powerful anecdote to anger or depression. Research has shown that the simple act of curving the corners of your mouth can increase your feeling of happiness. So don’t take life too seriously. Try to find humor and laughter in life’s everyday struggles.</em></p><p>笑是对抗生气或沮丧最有力的的东西。研究表明简单的嘴巴上扬也可以增加你的幸福感。不要把生活看得太严肃。要学会在每日的奋斗中寻找幽默感和笑声。</p><p><strong>09</strong></p><p><strong>Practice forgiveness</strong></p><p><strong>学会原谅</strong></p><p><em>Resentment and anger are forms of self-punishment. When you forgive, you’re actually practicing kindness to yourself. And most importantly, learn to forgive yourself. Everyone makes mistakes. It’s through our mistakes that we learn and grow to become a bigger and better person.</em></p><p>憎恨和生气是对自我的惩罚。当你释怀的时候，事实上你是在对自己施以善意。最重要的是，学会原谅自己。每个人都会犯错。只有通过我们的错误，我们才慢慢学会如何成为一个更强大，更好的人。</p><p><strong>Say thanks often</strong></p><p><strong>要经常说谢谢</strong></p><p><em>Always be appreciative of the blessings in your life. And it’s equally important to express your appreciation to those who’ve made your life better in some way, big or small.</em></p><p>对生活中的祝福要学会欣赏。向那些让你生活变好的人，无论或大或小，表达出你的欣赏之情也同样重要。</p><p><strong>11</strong></p><p><strong>Create deeper connections</strong></p><p><strong>学会深交</strong></p><p><em>Our happiness multiplies when we connect and bond with another human being on a deeper level. And being fully present and listening are two of the most important skills to strengthening that bond and bringing happiness to ourselves, and to others.</em></p><p>我们的幸福感会在和另一个人的交往中不断猛增。专注聆听是加强这种关系纽带和把幸福感带给自己和别人的两个最重要的方面。</p><p><strong>12</strong></p><p><strong>Keep your agreement</strong></p><p><strong>守承诺</strong></p><p><em>Our self-esteem is built on the agreements we’ve made with ourselves. And high self-esteem has a direct correlation to happiness. So keep your agreements with others and with yourself. Do what you say you’re going to do.</em></p><p>我们的自尊是建立在我们对自己守承诺的情况下。高度的自尊和幸福感有直接关联。所以要对自己和别人遵守承诺。言出必行。</p><p><strong>13</strong></p><p><strong>Meditate</strong></p><p><strong>冥想</strong></p><p><em>According to Harvard, people who take 8 sessions of mindfulness meditation training are, on average, 20% happier than a control group. Such training can lead to structural brain changes including increased grey-matter density in the hippocampus, known to be important for learning and memory, and in structures associated with self-awareness, compassion and introspection.</em></p><p>平均上，上过8次冥想训练的人要比控制狂多开心20%。这样的训练可以导致大脑结构变化，包括海马体黑色物质的密度，其对学习和记忆很重要，在结构上和自我意识，同情心和反省。</p><p><strong>14</strong></p><p><strong>Focus on what you’re doing</strong></p><p><strong>关注你在做的事情</strong></p><p><em>When you put your mind, heart and soul into what you’re doing, you’re creating a happiness state – called the “flow.” When you’re living in the flow, you’re less likely to care about what others may think of you, and less bothered by things that are not that important. The result? More happiness, of course!</em></p><p>当你全身心投入一件事的时候，你就会处于一个开心的状态。当我们处于这种状态，你就不大会关心别人对你怎么看，不大会被不大重要的事情干扰。结果呢？更幸福。</p><p><strong>15</strong></p><p><strong>Be optimistic</strong></p><p><strong>要乐观</strong></p><p><em>For happy people, the glass is always half-full. If your tendency is to imagine the very worst-case scenario every time you face a challenge, then train yourself to reverse that tendency. Ask yourself what good can come out of the situation or what you can learn from it. Optimism surely fuels success and happiness.</em></p><p>对于开心的人来说，玻璃水杯一直是半满的。每当你面对一个挑战时，如果你倾向于想象最坏的想法，那就自我转换这种情况。告诉你自己一个状况中的好处或者你从中学到的东西。乐观肯定能驱动成功和幸福感。</p><p><strong>16</strong></p><p><strong>Love unconditionally</strong></p><p><strong>无条件的爱</strong></p><p><em>No one is perfect. Accept yourself for all of your imperfections. And do so for others. Loving someone unconditionally does not mean that you need to spend all your time with them or help them figure out their problems. Unconditional love means accepting people as they are, and allowing them to find their own ways, at their own pace.</em></p><p>没人是完美的。接受你自己所有的不完美。也要这样对待别人。无条件的爱一个人并不意味着你要花所有的时间和他们在一起，或者帮助他们解决问题。无条件的爱意味着接受真实的他们，以他们自己的步伐，让他们自己摸索。</p><p><strong>17</strong></p><p><strong>Don’t give up.</strong></p><p><strong>不要放弃</strong></p><p><em>Unfinished projects and repeated defeats inevitably dampen one’s self-esteem. If you’ve made up your mind to do something, see it through. Don’t give up until you succeed. Remember, failure is temporary but defeat is permanent. And defeat only occurs when you give up.</em></p><p>没有完成的方案和不断的失败不可避免会削弱你的自尊。如果你决定做某事，做完它。在成功之前都不要放弃。要记住，失败是暂时的，打败的永存的。只有当你放弃的时候，你才会被打败。</p><p><strong>18</strong></p><p><strong>Do your best and then let go</strong></p><p><strong>做最好的自己，然后放手</strong></p><p><em>Everyone has limitations, and things don’t always turn out to be what we’d like them to be – despite our efforts. So always give your best, and then let go. Let events run their course. When you’ve done your best, you’ll have no regrets.</em></p><p>每个人都有局限性。而且有时候尽管我们很努力做一件事情，但是总会事与愿违。所以做最好的自己，然后放手。当你尽了全力，你就没有遗憾了。</p><p><strong>19</strong></p><p><strong>Take care of yourself</strong></p><p><strong>好好照顾自己</strong></p><p><em>A healthy body is the key to happiness. If you have poor health, it’s very difficult to be happy no matter how hard you try. So make sure you eat well, exercise and find time to rest. Take good care of your body, your mind and your spirit.</em></p><p>一个健康的身体是幸福的关键。如果你身体不好，你无论如何努力，都很难快乐。确信自己吃得好，做锻炼，找点时间休息。好好照顾你的身体，大脑和精神。</p><p><strong>20</strong></p><p><strong>Give back</strong></p><p><strong>学会给予</strong></p><p><em>Doing good is one of the surest ways to feel good. According to Harvard, when people do good, their brains becomes active in the very same reward center that is stimulated when they experience other rewards. So it’s not a surprise that people who care more about others are happier than those who care less about others.</em></p><p>做好事是最能确保你心情好的方法之一。根据哈佛，人们做好事，他们的大脑变得活跃，就好像当你经历别的奖励时，大脑所受的刺激。所以，那些关心别人的人要比不大关心别人的人更开心。</p><p>来源：哈佛大学</p>]]></content>
      
      
      <categories>
          
          <category> 业余 </category>
          
          <category> 阅读 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 阅读 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>生活需要调侃自己</title>
      <link href="/2019/11/27/%E7%94%9F%E6%B4%BB%E9%9C%80%E8%A6%81%E8%B0%83%E4%BE%83%E8%87%AA%E5%B7%B1/"/>
      <url>/2019/11/27/%E7%94%9F%E6%B4%BB%E9%9C%80%E8%A6%81%E8%B0%83%E4%BE%83%E8%87%AA%E5%B7%B1/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="学会调侃自己"><a href="#学会调侃自己" class="headerlink" title="学会调侃自己"></a>学会调侃自己</h2><p>或许，你也会有某些时刻：</p><p>​    工作上受了点委屈，看似不痛不痒，看似不痛不痒，若长久以此积累，更会让你疲惫不堪，心神乏力。</p><p>​    或生活中遇到一些麻烦或事，看似都无关紧要，可能影响你一天的心情，被这些琐事缠身，也会有感觉一种说不出来的无奈和疲倦。</p><p>​    或感情中产生一点矛盾，看似无伤大雅，但你比谁都清楚，一次次的失望，鸿沟越来越大，渐行渐远。</p><p>​    有时的你，很坚强。可以面对突然失业，突然离开，突发各种状况，面对父母你向一个强人，面对孩子你像一个超人，面对另一半你更像她的”大圣”,劈荆斩刺，无所不能。</p><p>​    但有时，你又是那么脆弱，被同事挤兑，被朋友开玩笑，被陌生人踩一脚，被恋人挂断的电话，你就悲伤的不能自已。</p><p>​    偶尔你也会怀疑自己，这究竟是怎么了？</p><p>​    本一切照旧，没发生过什么，也没有不愉快的事，更没有所谓的大喜和大悲，而你就是莫名的感到心里难受。</p><p>​    不是为了某个人，也不是为了某件事，更不是顾影自怜，你就想停下来，慰藉一下自己。</p><p>​    <strong>作为成年人来说呢，有时熬得太久，会感到苦；有时崩的太紧，会感到累；有时太忙太赶，也有喘不过气的时候；</strong></p><p>也许在旁人眼里，我每天的生活状态，都属于亢奋的状态。仿佛我随时有用不完的精力，在闲暇之余，也还有读书，写作，编程的时间。仿佛我随时都是良好的状态，并没有什么不开心的事情，也没有烦恼和忧愁。</p><p>​    其实，偶尔我也会有情绪低落的时刻。</p><p>通常我会保持沉默，不去向他人抱怨，也不需要过多的安慰和陪伴，让自己静下来，自嘲的说一句：“这有什么的呀！”逐渐的内心澄明开阔起来。</p><p>会好好吃饭，好好睡觉，让自己有一个良好的身体状态，早起洗漱时，自己给自己一个八分微笑，不给自己胡思乱想的机会，也不做无畏的消耗和纠缠。或去做一些令自己开心的事，比如去听一首动人的音乐，看一部感人的电影。</p><p>当你感受了人间美好，也就不必为一些无足轻重的人，一些鸡毛蒜皮的事，一些不堪回首的经历，伤心和哭泣。</p><p>曾经的我们感到不开心，会向父母撒娇，给朋友诉苦，或久久不能从悲伤，愤怒和糟糕的情绪里，跳脱出来，试着平复心情，调侃自己一句：“这有什么的呀！”。</p><p>​    每个人的不同年龄，不同阶段，不同境遇中，都会面对不一样的挫折、困难和麻烦。</p><p>也许，当你正身处其中时，会感到特别痛苦和煎熬。但当你走过了那段路，经过了那段岁月，有了那段体会后，再回来看会发现，一切烦恼和忧愁，原来都不过是过眼云烟。</p><p>或悲或喜，或聚或散，或得到或失去的，才是真实的人生。哭过，笑过，爱过，也才算不负此生。</p><p>所以不必去逃避，成长途中，所遇到的难和坎，因为那是你前行时，必须要经历的打磨和历练。</p><p>也不必去追求，所谓圆满的，平坦的，一帆风顺的生活，因为正是那些不完美，让你拥有丰富且宝贵的人生阅历。</p><p>也不必去执着于那些你很想要但得不到，很想拥有但已失去的东西，因为最终留下的，才值得你去珍惜和善待。</p><p>所以，我们只需用心过好每一天，踏实走好每一步，坦然地去面对一切未知的明天和未来。如果感到苦，就给自己吃一颗糖。如果感到累，就给自己捶捶背。如果感到难以压抑住的悲伤，那就去饱餐一顿，大睡一觉，第二天一早起床，阳光依旧普照。</p><p>记住每天请先给自己来一个八分笑。</p>]]></content>
      
      
      <categories>
          
          <category> 业余 </category>
          
          <category> 阅读 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 阅读 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hive-数据库操作(一)</title>
      <link href="/2019/09/25/Hive-%E6%95%B0%E6%8D%AE%E5%BA%93%E6%93%8D%E4%BD%9C-%E4%B8%80/"/>
      <url>/2019/09/25/Hive-%E6%95%B0%E6%8D%AE%E5%BA%93%E6%93%8D%E4%BD%9C-%E4%B8%80/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Hive-数据库操作-一"><a href="#Hive-数据库操作-一" class="headerlink" title="Hive-数据库操作(一)"></a><a href="www.zai1999.club">Hive-数据库操作(一)</a></h1><h2 id="创建数据库"><a href="#创建数据库" class="headerlink" title="创建数据库"></a>创建数据库</h2><p>hive创建数据库的最简单写法和mysql差不多：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`create` `database` `foo;`</span><br></pre></td></tr></table></figure><p>仅当名为foo的数据库当前不存在时才创建：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`create` `database` `if ``not` `exists foo;`</span><br></pre></td></tr></table></figure><p>创建数据库时指定位置，这个位置一般是在hdfs上的位置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`create` `database` `foo location ``&apos;/db/foo&apos;``;`</span><br></pre></td></tr></table></figure><h2 id="让提示符显示当前库："><a href="#让提示符显示当前库：" class="headerlink" title="让提示符显示当前库："></a>让提示符显示当前库：</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hive&gt;set hive.cli.print.current.db=true;</span><br></pre></td></tr></table></figure><h2 id="显示查询结果时显示字段名称："><a href="#显示查询结果时显示字段名称：" class="headerlink" title="显示查询结果时显示字段名称："></a>显示查询结果时显示字段名称：</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">set hive.resultset.use.unique.column.names=false;</span><br><span class="line"></span><br><span class="line">set hive.exec.mode.local.auto=true;</span><br></pre></td></tr></table></figure><p>这样设置每次启动hive都要从新来过，所以在 hive 目录下 conf/hive-site,xml 中添加如下配置</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">name</span>&gt;</span>hive.cli.print.header<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">value</span>&gt;</span>true<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">description</span>&gt;</span>Whether to print the names of the columns in query output.<span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">name</span>&gt;</span>hive.cli.print.current.db<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">value</span>&gt;</span>true<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">description</span>&gt;</span>Whether to include the current database in the Hive prompt.<span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></figure><p>查看已经创建的数据库：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`show databases ;`</span><br></pre></td></tr></table></figure><p>使用通配符查看foo开头的数据库：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`show databases ``like` `&apos;foo.*&apos;``;`</span><br></pre></td></tr></table></figure><p>查看创建数据库的语句：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`show ``create` `database` `foo ;`</span><br></pre></td></tr></table></figure><p>hive为每一个数据库创建一个目录，这个数据库中的表将会以子目录的形式放在这个数据库目录下</p><h2 id="数据库描述信息"><a href="#数据库描述信息" class="headerlink" title="数据库描述信息"></a>数据库描述信息</h2><p>在创建数据库时可以指定描述性信息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`create` `database` `foo comment ``&apos;this is foo database&apos;``;`</span><br></pre></td></tr></table></figure><p>通过describe database可以查看到数据库的详细信息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`describe ``database` `foo;`</span><br></pre></td></tr></table></figure><h2 id="数据库键值对信息"><a href="#数据库键值对信息" class="headerlink" title="数据库键值对信息"></a>数据库键值对信息</h2><p>数据库可以有一些描述性的键值对信息，在创建时添加：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`create` `database` `foo ``with` `dbproperties (``&apos;own&apos;``=``&apos;cc&apos;``, ``&apos;day&apos;``=``&apos;20180120&apos;``);`</span><br></pre></td></tr></table></figure><p>查看数据库的键值对信息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`describe ``database` `extended foo;`</span><br></pre></td></tr></table></figure><p>要修改数据库的键值对信息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`alter` `database` `foo ``set` `dbproperties (``&apos;k1&apos;``=``&apos;v1&apos;``, ``&apos;k2&apos;``=``&apos;v2&apos;``);`</span><br></pre></td></tr></table></figure><h2 id="删除数据库"><a href="#删除数据库" class="headerlink" title="删除数据库"></a>删除数据库</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`drop` `database` `if exists foo;`</span><br></pre></td></tr></table></figure><p>注意：</p><p>默认情况下是不允许直接删除一个有表的数据库的：</p><p>删除一个有表的数据库有两种办法：</p><p>\1. 先把表删干净，再删库。</p><p>\2. 删库时在后面加上cascade，表示级联删除此数据库下的所有表：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`drop` `database` `if exists foo ``cascade``;`</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 大数据 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hive笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>spring-mvc和xml配置理解</title>
      <link href="/2019/08/09/spring-mvc%E5%92%8Cxml%E9%85%8D%E7%BD%AE%E7%90%86%E8%A7%A3/"/>
      <url>/2019/08/09/spring-mvc%E5%92%8Cxml%E9%85%8D%E7%BD%AE%E7%90%86%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="spring-mvc-xml-和-application-context-xml的配置与深入理解"><a href="#spring-mvc-xml-和-application-context-xml的配置与深入理解" class="headerlink" title="spring-mvc.xml 和 application-context.xml的配置与深入理解"></a>spring-mvc.xml 和 application-context.xml的配置与深入理解</h1><p>1、application-context.xml是全局的，应用于多个serverlet，配合listener一起使用，web.xml中配置如下： </p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--  监听器  --&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">listener</span>&gt;</span>    </span><br><span class="line">    <span class="tag">&lt;<span class="name">listener-class</span>&gt;</span></span><br><span class="line"> org.springframework.web.context.request.RequestContextListener</span><br><span class="line">    <span class="tag">&lt;/<span class="name">listener-class</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">listener</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">listener</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">listener-class</span>&gt;</span>            org.springframework.web.context.ContextLoaderListener</span><br><span class="line">    <span class="tag">&lt;/<span class="name">listener-class</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">listener</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">context-param</span>&gt;</span>    </span><br><span class="line">    <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span>   </span><br><span class="line">    <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>classpath*:applicationContext.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span>    <span class="tag">&lt;/<span class="name">context-param</span>&gt;</span></span><br></pre></td></tr></table></figure><p>2、applicationContext-mvc.xml 是spring mvc的配置，web.xml中配置如下： </p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>springmvc<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">        org.springframework.web.servlet.DispatcherServlet</span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span>   </span><br><span class="line">    <span class="tag">&lt;<span class="name">init-param</span>&gt;</span>    </span><br><span class="line">        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span>    </span><br><span class="line">        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span></span><br><span class="line">            classpath*:applicationContext-mvc.xml</span><br><span class="line">        <span class="tag">&lt;/<span class="name">param-value</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">load-on-startup</span>&gt;</span>1<span class="tag">&lt;/<span class="name">load-on-startup</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span>   </span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>springmvc<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure><p> application-context.xml这个一般是采用非spring mvc架构，用来加载Application Context。</p><p><strong>如果直接采用SpringMVC，只需要把所有相关配置放到spring-mvc.xml中就好，一般spring mvc项目用不到多个serverlet。</strong></p><h2 id="1、首先介绍一下启动一个项目的整体流程："><a href="#1、首先介绍一下启动一个项目的整体流程：" class="headerlink" title="1、首先介绍一下启动一个项目的整体流程："></a>1、首先介绍一下启动一个项目的整体流程：</h2><p>1.tomcat启动一个WEB项目的时候，WEB容器会去读取它的配置文件web.xml，读取<listener>和<context-param>两个结点。</context-param></listener></p><p>2.紧接着，容器创建一个ServletContext（servlet上下文，全局的），这个web项目的所有部分都将共享这个上下文。可以把ServletContext看成是一个Web应用的服务器端组件的共享内存，在ServletContext中可以存放共享数据。ServletContext对象是真正的一个全局对象，凡是web容器中的Servlet都可以访问</p><p>3.容器将<context-param>转换为键值对，并交给servletContext。</context-param></p><p>4.<strong>容器创建<listener>中的类实例，创建监听器。  listener中ContextLoaderListener监听器的作用就是启动Web容器时，监听servletContext对象的变化，获取servletContext对象的<context-param>，来自动装配ApplicationContext的配置信息。（即加载applicationContext.xml文件）</context-param></listener></strong></p><h2 id="2、现在开始正式讲解applicationContext-xml中的配置内容"><a href="#2、现在开始正式讲解applicationContext-xml中的配置内容" class="headerlink" title="2、现在开始正式讲解applicationContext.xml中的配置内容"></a>2、现在开始正式讲解applicationContext.xml中的配置内容</h2><p>1、<strong>扫描service层和dao层注解（spring中扫描service，然后再在SpringMVC中扫描controller中扫描controller。 因为如果Controller在主容器中进行扫描的话会扫描到原样的service，那时service还没有进行事务处理可能会引起事务失效）</strong></p><p>  A、  <a href="context:annotation-config/" target="_blank" rel="noopener">context:annotation-config/</a>   ： 自动简化的完成相应bean的声明。</p><pre><code>启动spring的一些注解，主要包括：向 Spring 容器注册如下4 个BeanPostProcessor。</code></pre><ol><li><p>AutowiredAnnotationBeanPostProcessor       @Autowired注解</p></li><li><p>CommonAnnotationBeanPostProcessor       @ Resource 、@ PostConstruct、@ PreDestroy</p></li><li><p>PersistenceAnnotationBeanPostProcessor     @PersistenceContext注解</p></li><li><p>RequiredAnnotationBeanPostProcessor 这     @Required的注解</p><pre><code>注册这4个 BeanPostProcessor的作用，就是为了你的系统能够识别相应的注解。</code></pre><p><a href="context:annotation-config/" target="_blank" rel="noopener">context:annotation-config/</a>的方式等价于以下的传统方式：</p><pre><code>&lt;bean class=&quot;org.springframework.beans.factory.annotation. AutowiredAnnotationBeanPostProcessor &quot;/&gt; </code></pre><p>但是配置更加简单，方便，不需要按照传统的方式一条一条配置显得有些繁琐和没有必要，于是spring给我们提供<a href="context:annotation-config/" target="_blank" rel="noopener">context:annotation-config/</a>的简化配置方式，自动帮你完成声明。</p><p>B、  设置使用注解的类所在的包 主要是dao层和service层，剔除controller层注解扫描</p><p>注意，这部分主要是扫描项目中除了controller以外的其他层的注解。配置这部分的目的是在于扫描service包和dao包里面的类，只要有@Service或者@Repository就注册成spring容器中的Bean,下次可以通过@Autowired直接注入。</p><pre><code>如果有B的配置，可以不需要A的配置，&lt;context:component-scan base-package=”XX.XX”/&gt; ， 该配置项其实也包含了自动注入上述processor的功能，因此当使用 &lt;context:component-scan/&gt; 后，就可以将 &lt;context:annotation-config/&gt; 移除了。</code></pre></li></ol><p>2、配置数据库相关内容（这部分内容可以单独用一个spring-mybatis.xml进行配置，本项目没有单独进行配置，而是和applicaitonContext.xml文件一起配置的）</p><p>配置db.properties文件—–》配置数据源（dataSource（可以采用数据库连接池），可以配置多个数据源（如果有多个数据库的话））—》配置spring+mybatis(Spring和Mybatis整合有两种方式)—-》配置事务（事务管理器、配置事务传播特性、事务aop配置）</p><p>db.properties内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">jdbc.driver=com.mysql.jdbc.Driverjdbc</span><br><span class="line">jdbc.url=jdbc:mysql://127.0.0.1:3306/smbms?useUnicode=true&amp;characterEncoding=utf-8</span><br><span class="line">jdbc.username=root</span><br><span class="line">jdbc.password=root</span><br></pre></td></tr></table></figure><p>3.在applicationContext.xml中配置数据源，后期需要可以在其中添加多个属性配置。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--  引入配置文件  --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context:property-placeholder</span> <span class="attr">location</span>=<span class="string">"classpath*:db.properties"</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!--  配置数据源  --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"dataSource"</span> <span class="attr">class</span>=<span class="string">"com.mchange.v2.c3p0.ComboPooledDataSource"</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"password"</span> <span class="attr">value</span>=<span class="string">"$&#123;jdbc.password&#125;"</span>/&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"driverClass"</span> <span class="attr">value</span>=<span class="string">"$&#123;jdbc.driver&#125;"</span>/&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"user"</span> <span class="attr">value</span>=<span class="string">"$&#123;jdbc.username&#125;"</span>/&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"jdbcUrl"</span> <span class="attr">value</span>=<span class="string">"$&#123;jdbc.url&#125;"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>配置spring+mybatis（主要是获取sqlSession对象，通过MapperScannerConfigurer 自动装配SqlSessionFactory 或 SqlSessionTemplate，MapperFactoryBean 创建的代理类实现了 UserMapper 接口,并且注入到应用程序中）</p><h5 id="创建SqlSessionFactory的过程："><a href="#创建SqlSessionFactory的过程：" class="headerlink" title="创建SqlSessionFactory的过程："></a>创建SqlSessionFactory的过程：</h5><p>①定义Configuration对象(包括数据源，事务，mapper文件资源以及影响数据库行为属性设置的settings)<br>–&gt; ②由Configuration对象创建一个SqlSessionFactoryBuilder对象<br>–&gt; ③由SessionFactoryBuilder获得SqlSessionFactory实例<br>–&gt; ④由SqlSessionFactory实例获得SqlSession实例，操作数据库<br>      在 MyBatis 中，使用 SqlSessionFactoryBuilder创建SqlSessionFactory ，进而来创建 SqlSession。一旦你获得一个 session 之后,你可以使用它来执行映射语句,提交或回滚连接,最后,当不再需要它的时候, 你可以关闭 session。 </p><p>  Mybatis社区自己开发了一个Mybatis-Spring用来满足Mybatis用户整合Spring的需求。使用 MyBatis-Spring 之后, 会使用SqlSessionFactoryBean来代替SqlSessionFactoryBuilder创建SqlSessionFactory，然后可以使用下面两种方式使用sqlSession。1、SqlSessionTemplate；2、SqlSessionDaoSupport；上面做法没问题，但就是在spring.xml中需要配置所有的dao层实现，把sqlSession或者sqlSessionFactory注入进去，可以使用MapperScannerConfigurer来解决这个问题，MapperScannerConfigurer帮我们自动装配SqlSessionFactory 或 SqlSessionTemplate，因此不需要我们在applicationContext.xml文件中注入sqlSession或者sqlSessionFactory。</p><p>   SqlSessionFactoryBean、SqlSessionFactory、SqlSession、SqlSessionTemplate之间的关系。</p><p> SqlSessionFactoryBean是生产SqlSessionFactory的一种工厂Bean；SqlSessionFactory是一种生产SqlSession的工厂；SqlSession是代表数据库连接客户端和数据库Server之间的会话信息；SqlSessionTemplate是SqlSession的一个具体实现。</p><h5 id><a href="#" class="headerlink" title=" "></a> </h5><h5 id="SqlSessionTemplate介绍："><a href="#SqlSessionTemplate介绍：" class="headerlink" title="SqlSessionTemplate介绍："></a>SqlSessionTemplate介绍：</h5><p> Mybatis-Spring提供了一种直接使用SqlSession的方式（一个实现了SqlSession接口的SqlSessionTemplate实现类）</p><p>  1、它是线程安全的，可以被多个Dao同时使用；</p><p>   2、 它跟Spring的事务进行了关联，确保当前被使用的SqlSession是一个已经和Spring的事务进行绑定了的，而且它还可以自己管理Session的提交和关闭。</p><p><strong>applicationContext.xml配置：Spring和Mybatis整合有两种方式</strong></p><p><strong>方式一：需要mapper.xml文件</strong>，mapper文件里面写sql语句，UserMapper接口类里面不写sql语句</p><p><strong>方式二：不需要mapper.xml文件</strong>,但是需要在UserMapper里面写sql语句</p><p><strong>需要配置MapperScannerConfigurer 自动扫描 将Mapper接口生成代理注入到Spring，这部分实现mapper.xml文件映射成mapper接口类的实现类，自动注入到spring中，这样我们就不用写mapper接口的实现类了。</strong></p><p>原理：Mybatis在与Spring集成的时候可以配置MapperFactoryBean来生成Mapper接口的代理，MapperFactoryBean 创建的代理类实现了 UserMapper 接口,并且注入到应用程序中。 因为代理创建在运行时环境中(Runtime,译者注) ,那么指定的映射器必须是一个接口,而 不是一个具体的实现类。<strong>MapperScannerConfigurer</strong> , 它 将 会 查 找 类 路 径 下 的 映 射 器 并 自 动 将 它 们 创 建 成 <strong>MapperFactoryBean</strong>。（需要增加对MapperFactoryBean源码的理解）</p><p>   注 意 , 没 有 必 要 去 指 定 SqlSessionFactory 或 SqlSessionTemplate , 因 为 MapperScannerConfigurer 将会创建 MapperFactoryBean,之后自动装配。但是,如果你使 用了一个 以上的 DataSource ,那 么自动 装配可 能会失效 。这种 情况下 ,你可 以使用 sqlSessionFactoryBeanName 或 sqlSessionTemplateBeanName 属性来设置正确的 bean 名 称来使用。这就是它如何来配置的,注意 bean 的名称是必须的,而不是 bean 的引用,因 此,value 属性在这里替代通常的 ref。</p><p>事务管理的两种方式：    </p><pre><code>事务管理对于企业应用而言，是至关重要的，即使出现异常情况，他也可以保证数据的一致性。事务的管理方式有两种：1、支持编程式事务管理2、支持声明式事务管理方式。编程式事务管理是使用：TransactionTemplate，声明式事务管理建立在AOP之上，其本质是对方法前后进行拦截，然后在目标方法开始之前创建或者加入一个事务，在执行完目标方法之后，根据执行情况提交或者回滚事务。声明式事务的优点是可以基于注解@Transactional来管理，很方便，但是不足之处在于粒度较大，只能作用到方法级别，不能像编程式事务那样，做到代码块级别。</code></pre><h3 id="applicationContext-mvc-xml的配置"><a href="#applicationContext-mvc-xml的配置" class="headerlink" title="applicationContext-mvc.xml的配置"></a>applicationContext-mvc.xml的配置</h3><p> web项目启动时，读取web.xml配置文件，首先解析的是applicationContext.xml文件，其次才是sping-mvc.xml文件，sping-mvc.xml文件中主要的工作是：启动注解、扫描controller包注解；静态资源映射；视图解析（defaultViewResolver）；文件上传（multipartResolver）;返回消息json配置。</p><p>mvc执行流程图</p><p><img src="http://ww.zai1999.club/img/spring/mvc%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B.jpg" alt="img" data-src="http://ww.zai1999.club/img/spring/mvc%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B.jpg" class="lazyload"></p><p> 1.自动扫描</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 自动扫描该包，使SpringMVC认为包下用了@controller注解的类是控制器 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">"com.javen.controller"</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>2.注解驱动</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 扩充了注解驱动，可以将请求参数绑定到控制参数--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mvc:annotation-driven</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>3.静态资源处理</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 静态资源处理 css js images --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mvc:resources</span> <span class="attr">location</span>=<span class="string">"/resources/**"</span> <span class="attr">mapping</span>=<span class="string">"/resource/"</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>4.避免IE执行AJAX时，返回JSON出现下载文件</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 避免IE执行AJAX时，返回JSON出现下载文件 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"mappingJacksonHttpMessageConverter"</span> </span></span><br><span class="line"><span class="tag"><span class="attr">class</span>=<span class="string">"org.springframework.http.converter.json.MappingJacksonHttpMessageConverter"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"supportedMediaTypes"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">list</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">value</span>&gt;</span>text/html;charset=UTF-8<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">list</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>5.启动SpringMVC的注解功能，完成请求和注解POJO的映射</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 启动SpringMVC的注解功能，完成请求和注解POJO的映射 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.springframework.web.servlet.mvc.annotation.AnnotationMethodHandlerAdapter"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"messageConverters"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">list</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">ref</span> <span class="attr">bean</span>=<span class="string">"mappingJacksonHttpMessageConverter"</span>/&gt;</span><span class="comment">&lt;!-- JSON转换器 --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">list</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>6.配置文件上传</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 配置文件上传，如果没有使用文件上传可以不用配置，当然如果不配，那么配置文件中也不必引入上传组件包 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"multipartResolver"</span></span></span><br><span class="line"><span class="tag"><span class="attr">class</span>=<span class="string">"org.springframework.web.multipart.commons.CommonsMultipartResolver"</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 默认编码 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"defaultEncoding"</span> <span class="attr">value</span>=<span class="string">"utf-8"</span> /&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 上传文件最大值 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"maxUploadSize"</span> <span class="attr">value</span>=<span class="string">"10485760000"</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 内存中的最大值 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"maxInMemorySize"</span> <span class="attr">value</span>=<span class="string">"40960"</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 启用是为了推迟文件解析，以便捕获文件大小异常 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"resolveLazily"</span> <span class="attr">value</span>=<span class="string">"true"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>7.配置viewResolver视图解析</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 配置viewResolver。可以用多个viewResolver。使用order属性排序。InternalResourceViewResolver 放在最后 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.springframework.web.servlet.view.ContentNegotiatingViewResolver"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"order"</span> <span class="attr">value</span>=<span class="string">"1"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"mediaTypes"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">map</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 告诉视图解析器，返回的类型为json格式 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">"json"</span> <span class="attr">value</span>=<span class="string">"application/json"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">"xml"</span> <span class="attr">value</span>=<span class="string">"application/xml"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">"htm"</span> <span class="attr">value</span>=<span class="string">"text/htm"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">map</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"defaultViews"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">list</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- ModelAndView里的数据变成JSON --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.springframework.web.servlet.view.json.MappingJacksonJsonView"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">list</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"ignoreAcceptHeader"</span> <span class="attr">value</span>=<span class="string">"true"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>8.定义跳转的文件的前后缀 ，视图模式配置</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 定义跳转的文件的前后缀 ，视图模式配置--&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.springframework.web.servlet.view.InternalResourceViewResolver"</span>&gt;</span> </span><br><span class="line"><span class="comment">&lt;!-- 这里的配置我的理解是自动给后面action的方法return的字符串加上前缀和后缀，变成一个 可用的url地址 --&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"prefix"</span> <span class="attr">value</span>=<span class="string">"/WEB-INF/jsp/"</span> /&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"suffix"</span> <span class="attr">value</span>=<span class="string">".jsp"</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>本文参考来自<a href="https://blog.csdn.net/qq_35571554/article/details/82453684" target="_blank" rel="noopener">「夏至&amp;未至」</a></p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
          <category> spring-mvc </category>
          
      </categories>
      
      
        <tags>
            
            <tag> spring-mvc </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring学习-1</title>
      <link href="/2019/08/01/Spring%E5%AD%A6%E4%B9%A0-1/"/>
      <url>/2019/08/01/Spring%E5%AD%A6%E4%B9%A0-1/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Spring学习-1-——快速入门"><a href="#Spring学习-1-——快速入门" class="headerlink" title="Spring学习(1)——快速入门"></a><a href="http://www.zai1999.club">Spring学习(1)——快速入门</a></h1><p><img src="http://ww.zai1999.club/img/spring/spring-tu.png" alt="img" data-src="http://ww.zai1999.club/img/spring/spring-tu.png" class="lazyload"></p><h2 id="认识-Spring-框架"><a href="#认识-Spring-框架" class="headerlink" title="认识 Spring 框架"></a>认识 Spring 框架</h2><p>Spring 框架是 Java 应用最广的框架，它的<strong>成功来源于理念，而不是技术本身</strong>，它的理念包括 <strong>IoC (Inversion of Control，控制反转)</strong> 和 <strong>AOP(Aspect Oriented Programming，面向切面编程)</strong>。</p><h4 id="什么是-Spring："><a href="#什么是-Spring：" class="headerlink" title="什么是 Spring："></a>什么是 Spring：</h4><ol><li>Spring 是一个<strong>轻量级的 DI / IoC 和 AOP 容器的开源框架</strong>，来源于 Rod Johnson 在其著作<strong>《Expert one on one J2EE design and development》</strong>中阐述的部分理念和原型衍生而来。</li><li>Spring 提倡以<strong>“最少侵入”</strong>的方式来管理应用中的代码，这意味着我们可以随时安装或者卸载 Spring</li></ol><ul><li><strong>适用范围：任何 Java 应用</strong></li><li><strong>Spring 的根本使命：简化 Java 开发</strong></li></ul><blockquote><p>尽管 J2EE 能够赶上 Spring 的步伐，<strong>但 Spring 并没有停止前进，</strong> Spring 继续在其他领域发展，而 J2EE 则刚刚开始涉及这些领域，或者还没有完全开始在这些领域的创新。<strong>移动开发、社交 API 集成、NoSQL 数据库、云计算以及大数据</strong>都是 Spring 正在涉足和创新的领域。Spring 的前景依然会很美好。</p></blockquote><h4 id="Spring-中常用术语："><a href="#Spring-中常用术语：" class="headerlink" title="Spring 中常用术语："></a>Spring 中常用术语：</h4><ul><li><strong>框架：</strong>是能<strong>完成一定功能</strong>的<strong>半成品</strong>。<br>框架能够帮助我们完成的是：<strong>项目的整体框架、一些基础功能、规定了类和对象如何创建，如何协作等</strong>，当我们开发一个项目时，框架帮助我们完成了一部分功能，我们自己再完成一部分，那这个项目就完成了。</li><li><strong>非侵入式设计：</strong><br>从框架的角度可以理解为：<strong>无需继承框架提供的任何类</strong><br>这样我们在更换框架时，之前写过的代码几乎可以继续使用。</li><li><strong>轻量级和重量级：</strong><br>轻量级是相对于重量级而言的，<strong>轻量级一般就是非入侵性的、所依赖的东西非常少、资源占用非常少、部署简单等等</strong>，其实就是<strong>比较容易使用</strong>，而<strong>重量级正好相反</strong>。</li><li><strong>JavaBean：</strong><br>即<strong>符合 JavaBean 规范</strong>的 Java 类</li><li><strong>POJO：</strong>即 <strong>Plain Old Java Objects，简单老式 Java 对象</strong><br>它可以包含业务逻辑或持久化逻辑，但<strong>不担当任何特殊角色</strong>且<strong>不继承或不实现任何其它Java框架的类或接口。</strong></li></ul><p><em>注意：bean 的各种名称——虽然 Spring 用 bean 或者 JavaBean 来表示应用组件，但并不意味着 Spring 组件必须遵循 JavaBean 规范，一个 Spring 组件可以是任意形式的 POJO。</em></p><ul><li><strong>容器：</strong><br>在日常生活中容器就是一种盛放东西的器具，从程序设计角度看就是<strong>装对象的的对象</strong>，因为存在<strong>放入、拿出等</strong>操作，所以容器还要<strong>管理对象的生命周期</strong>。</li></ul><h4 id="Spring-的优势"><a href="#Spring-的优势" class="headerlink" title="Spring 的优势"></a>Spring 的优势</h4><ul><li><strong>低侵入 / 低耦合</strong> （降低组件之间的耦合度，实现软件各层之间的解耦）</li><li><strong>声明式事务管理</strong>（基于切面和惯例）</li><li><strong>方便集成其他框架</strong>（如MyBatis、Hibernate）</li><li><strong>降低 Java 开发难度</strong></li><li>Spring 框架中包括了 J2EE 三层的每一层的解决方案（一站式）</li></ul><h4 id="Spring-能帮我们做什么"><a href="#Spring-能帮我们做什么" class="headerlink" title="Spring 能帮我们做什么"></a>Spring 能帮我们做什么</h4><p><strong>①.Spring</strong> 能帮我们根据配置文件<strong>创建及组装对象之间的依赖关系</strong>。<br><strong>②.Spring 面向切面编程</strong>能帮助我们<strong>无耦合的实现日志记录，性能统计，安全控制。</strong><br><strong>③.Spring</strong> 能<strong>非常简单的帮我们管理数据库事务</strong>。<br><strong>④.Spring</strong> 还<strong>提供了与第三方数据访问框架（如Hibernate、JPA）无缝集成</strong>，而且自己也提供了一套<strong>JDBC访问模板</strong>来方便数据库访问。<br><strong>⑤.Spring</strong> 还提供与<strong>第三方Web（如Struts1/2、JSF）框架无缝集成</strong>，而且自己也提供了一套<strong>Spring MVC</strong>框架，来方便web层搭建。<br><strong>⑥.Spring</strong> 能<strong>方便的与Java EE（如Java Mail、任务调度）整合</strong>，与<strong>更多技术整合（比如缓存框架）</strong>。</p><h4 id="Spring-的框架结构"><a href="#Spring-的框架结构" class="headerlink" title="Spring 的框架结构"></a>Spring 的框架结构</h4><p><img src="http://ww.zai1999.club/img/spring/spring-bh.png" alt="img" data-src="http://ww.zai1999.club/img/spring/spring-bh.png" class="lazyload"></p><ul><li><strong>Data Access/Integration层</strong>包含有JDBC、ORM、OXM、JMS和Transaction模块。</li><li><strong>Web层</strong>包含了Web、Web-Servlet、WebSocket、Web-Porlet模块。</li><li><strong>AOP模块</strong>提供了一个符合AOP联盟标准的面向切面编程的实现。</li><li><strong>Core Container(核心容器)：</strong>包含有Beans、Core、Context和SpEL模块。</li><li><strong>Test模块</strong>支持使用JUnit和TestNG对Spring组件进行测试。</li></ul><hr><h2 id="Spring-IoC-和-DI-简介"><a href="#Spring-IoC-和-DI-简介" class="headerlink" title="Spring IoC 和 DI 简介"></a>Spring IoC 和 DI 简介</h2><h4 id="IoC：Inverse-of-Control（控制反转）"><a href="#IoC：Inverse-of-Control（控制反转）" class="headerlink" title="IoC：Inverse of Control（控制反转）"></a>IoC：Inverse of Control（控制反转）</h4><ul><li>读作<strong>“反转控制”</strong>，更好理解，不是什么技术，而是一种<strong>设计思想</strong>，就是<strong>将原本在程序中手动创建对象的控制权，交由Spring框架来管理。</strong></li><li><strong>正控：</strong>若要使用某个对象，需要<strong>自己去负责对象的创建</strong></li><li><strong>反控：</strong>若要使用某个对象，只需要<strong>从 Spring 容器中获取需要使用的对象，不关心对象的创建过程</strong>，也就是把<strong>创建对象的控制权反转给了Spring框架</strong></li><li><strong>好莱坞法则：</strong>Don’t call me ,I’ll call you</li></ul><h4 id="一个例子"><a href="#一个例子" class="headerlink" title="一个例子"></a>一个例子</h4><p>控制反转显然是一个抽象的概念，我们举一个鲜明的例子来说明。</p><p>在现实生活中，人们要用到一样东西的时候，第一反应就是去找到这件东西，比如想喝新鲜橙汁，在没有饮品店的日子里，最直观的做法就是：买果汁机、买橙子，然后准备开水。值得注意的是：这些都是你自己<strong>“主动”创造</strong>的过程，也就是说一杯橙汁需要你自己创造。</p><p><img src="http://ww.zai1999.club/img/spring/spring-lt-1.png" alt="img" data-src="http://ww.zai1999.club/img/spring/spring-lt-1.png" class="lazyload"></p><p>然而到了今时今日，由于饮品店的盛行，当我们想喝橙汁时，第一想法就转换成了找到饮品店的联系方式，通过电话等渠道描述你的需要、地址、联系方式等，下订单等待，过一会儿就会有人送来橙汁了。</p><p><img src="http://ww.zai1999.club/img/spring/spring-lt-2.png" alt="img" data-src="http://ww.zai1999.club/img/spring/spring-lt-2.png" class="lazyload"></p><p><strong>请注意你并没有“主动”去创造橙汁</strong>，橙汁是由饮品店创造的，而不是你，然而也完全达到了你的要求，甚至比你创造的要好上那么一些。</p><h4 id="编写第一个-Spring-程序"><a href="#编写第一个-Spring-程序" class="headerlink" title="编写第一个 Spring 程序"></a>编写第一个 Spring 程序</h4><ol><li>新建一个空的 Java 项目，命名为【spring】</li><li>新建一个名为【lib】的目录，并添加进必要的 jar 包，导入项目(可以自己去找兼容版本)</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-beans<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.0.6.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-context<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.0.6.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.0.6.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-tx<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.0.6.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-expression<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.0.6.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-aspects<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.0.6.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-aop<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.0.6.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>aopalliance<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>aopalliance<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.aspectj<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>aspectjweaver<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.8.13<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--测试包--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.12<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--日志管理 start--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>ch.qos.logback<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>logback-classic<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.1.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>compile<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>ch.qos.logback<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>logback-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.1.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>compile<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--日志管理 end--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--        &lt;dependency&gt;--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--            &lt;groupId&gt;org.slf4j&lt;/groupId&gt;--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--            &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt;--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--            &lt;version&gt;1.6.1&lt;/version&gt;--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--        &lt;/dependency&gt;--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.18.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>log4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>log4j<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.17<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><ol><li>在 Packge【pojo】下新建一个【Source】类：</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> pojo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Source</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">private</span> String fruit;   <span class="comment">// 类型</span></span><br><span class="line">    <span class="keyword">private</span> String sugar;   <span class="comment">// 糖分描述</span></span><br><span class="line">    <span class="keyword">private</span> String size;    <span class="comment">// 大小杯    </span></span><br><span class="line">    <span class="comment">/* setter and getter */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>在 【src】 目录下新建一个 【applicationContext.xml】 文件，通过 xml 文件配置的方式装配我们的 bean</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">name</span>=<span class="string">"source"</span> <span class="attr">class</span>=<span class="string">"pojo.Source"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"fruit"</span> <span class="attr">value</span>=<span class="string">"橙子"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"sugar"</span> <span class="attr">value</span>=<span class="string">"多糖"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"size"</span> <span class="attr">value</span>=<span class="string">"超大杯"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><ol><li>在 Packge【test】下新建一个【TestSpring】类：</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.ApplicationContext;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.support.ClassPathXmlApplicationContext;</span><br><span class="line"><span class="keyword">import</span> pojo.Source;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestSpring</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">        ApplicationContext context = <span class="keyword">new</span> ClassPathXmlApplicationContext(</span><br><span class="line">                <span class="keyword">new</span> String[]&#123;<span class="string">"applicationContext.xml"</span>&#125;</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        Source source = (Source) context.getBean(<span class="string">"source"</span>);</span><br><span class="line">        System.out.println(source.getFruit());</span><br><span class="line">        System.out.println(source.getSugar());</span><br><span class="line">        System.out.println(source.getSize());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><p>运行测试代码，可以正常拿到 xml 配置的 bean</p><p>控制台中输出bean的值</p></li></ol><ul><li><strong>总结：</strong></li><li><strong>传统的方式：</strong><br>通过new 关键字主动创建一个对象</li><li><strong>IOC方式：</strong><br>对象的生命周期由Spring来管理，直接从Spring那里去获取一个对象。 IOC是反转控制 (Inversion Of Control)的缩写，就像控制权从本来在自己手里，交给了Spring。<br><img src="http://ww.zai1999.club/img/spring/spring-dx.png" alt="获取对象方式的转变" data-src="http://ww.zai1999.club/img/spring/spring-dx.png" class="lazyload"></li></ul><blockquote><p>参考地址：<a href="http://how2j.cn/k/spring/spring-ioc-di/87.html#nowhere" target="_blank" rel="noopener">这里</a></p></blockquote><h4 id="DI：Dependency-Injection（依赖注入）"><a href="#DI：Dependency-Injection（依赖注入）" class="headerlink" title="DI：Dependency Injection（依赖注入）"></a>DI：Dependency Injection（依赖注入）</h4><ul><li>指 Spring 创建对象的过程中，<strong>将对象依赖属性（简单值，集合，对象）通过配置设值给该对象</strong></li></ul><h4 id="继续上面的例子"><a href="#继续上面的例子" class="headerlink" title="继续上面的例子"></a>继续上面的例子</h4><ol><li>在 Packge【pojo】下新建一个【JuiceMaker】类：</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> pojo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JuiceMaker</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 唯一关联了一个 Source 对象</span></span><br><span class="line">    <span class="keyword">private</span> Source source = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* setter and getter */</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">makeJuice</span><span class="params">()</span></span>&#123;</span><br><span class="line">        String juice = <span class="string">"xxx用户点了一杯"</span> + source.getFruit() + source.getSugar() + source.getSize();</span><br><span class="line">        <span class="keyword">return</span> juice;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>在 xml 文件中配置 JuiceMaker 对象：</li></ol><ul><li><strong>注意：</strong>这里要使用 ref 来<strong>注入</strong>另一个对象</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">name</span>=<span class="string">"source"</span> <span class="attr">class</span>=<span class="string">"pojo.Source"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"fruit"</span> <span class="attr">value</span>=<span class="string">"橙子"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"sugar"</span> <span class="attr">value</span>=<span class="string">"多糖"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"size"</span> <span class="attr">value</span>=<span class="string">"超大杯"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">name</span>=<span class="string">"juickMaker"</span> <span class="attr">class</span>=<span class="string">"pojo.JuiceMaker"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"source"</span> <span class="attr">ref</span>=<span class="string">"source"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><ol><li>在 【TestSpring】 中添加如下代码：</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.ApplicationContext;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.support.ClassPathXmlApplicationContext;</span><br><span class="line"><span class="keyword">import</span> pojo.JuiceMaker;</span><br><span class="line"><span class="keyword">import</span> pojo.Source;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestSpring</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">        ApplicationContext context = <span class="keyword">new</span> ClassPathXmlApplicationContext(</span><br><span class="line">                <span class="keyword">new</span> String[]&#123;<span class="string">"applicationContext.xml"</span>&#125;</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        Source source = (Source) context.getBean(<span class="string">"source"</span>);</span><br><span class="line">        System.out.println(source.getFruit());</span><br><span class="line">        System.out.println(source.getSugar());</span><br><span class="line">        System.out.println(source.getSize());</span><br><span class="line"></span><br><span class="line">        JuiceMaker juiceMaker = (JuiceMaker) context.getBean(<span class="string">"juickMaker"</span>);</span><br><span class="line">        System.out.println(juiceMaker.makeJuice());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>总结：</strong>IoC 和 DI 其实是同一个概念的不同角度描述，DI 相对 IoC 而言，<strong>明确描述了“被注入对象依赖 IoC 容器配置依赖对象”</strong></p><h4 id="IoC-如何实现的"><a href="#IoC-如何实现的" class="headerlink" title="IoC 如何实现的"></a>IoC 如何实现的</h4><p>最后我们简单说说IoC是如何实现的。想象一下如果我们自己来实现这个依赖注入的功能，我们怎么来做？ 无外乎：</p><ol><li>读取标注或者配置文件，看看JuiceMaker依赖的是哪个Source，拿到类名</li><li>使用反射的API，基于类名实例化对应的对象实例</li><li>将对象实例，通过构造函数或者 setter，传递给 JuiceMaker</li></ol><p>我们发现其实自己来实现也不是很难，Spring实际也就是这么做的。这么看的话其实IoC就是一个工厂模式的升级版！当然要做一个成熟的IoC框架，还是非常多细致的工作要做，Spring不仅提供了一个已经成为业界标准的Java IoC框架，还提供了更多强大的功能，所以大家就别去造轮子啦！希望了解IoC更多实现细节不妨通过学习Spring的源码来加深理解！</p><blockquote><p>引用地址：<a href="https://www.tianmaying.com/tutorial/spring-ioc" target="_blank" rel="noopener">这里</a></p></blockquote><hr><h2 id="Spring-AOP-简介"><a href="#Spring-AOP-简介" class="headerlink" title="Spring AOP 简介"></a>Spring AOP 简介</h2><p>如果说 IoC 是 Spring 的核心，那么面向切面编程就是 Spring 最为重要的功能之一了，在数据库事务中切面编程被广泛使用。</p><h4 id="AOP-即-Aspect-Oriented-Program-面向切面编程"><a href="#AOP-即-Aspect-Oriented-Program-面向切面编程" class="headerlink" title="AOP 即 Aspect Oriented Program 面向切面编程"></a>AOP 即 Aspect Oriented Program 面向切面编程</h4><p>首先，在面向切面编程的思想里面，把功能分为核心业务功能，和周边功能。</p><ul><li><strong>所谓的核心业务</strong>，比如登陆，增加数据，删除数据都叫核心业务</li><li><strong>所谓的周边功能</strong>，比如性能统计，日志，事务管理等等</li></ul><p>周边功能在 Spring 的面向切面编程AOP思想里，即被定义为切面</p><p>在面向切面编程AOP的思想里面，核心业务功能和切面功能分别独立进行开发，然后把切面功能和核心业务功能 “编织” 在一起，这就叫AOP</p><h4 id="AOP-的目的"><a href="#AOP-的目的" class="headerlink" title="AOP 的目的"></a>AOP 的目的</h4><p>AOP能够将那些与业务无关，<strong>却为业务模块所共同调用的逻辑或责任（例如事务处理、日志管理、权限控制等）封装起来</strong>，便于<strong>减少系统的重复代码</strong>，<strong>降低模块间的耦合度</strong>，并<strong>有利于未来的可拓展性和可维护性</strong>。</p><h4 id="AOP-当中的概念："><a href="#AOP-当中的概念：" class="headerlink" title="AOP 当中的概念："></a>AOP 当中的概念：</h4><ul><li>切入点（Pointcut）<br>在哪些类，哪些方法上切入（<strong>where</strong>）</li><li>通知（Advice）<br>在方法执行的什么实际（<strong>when:</strong>方法前/方法后/方法前后）做什么（<strong>what:</strong>增强的功能）</li><li>切面（Aspect）<br>切面 = 切入点 + 通知，通俗点就是：<strong>在什么时机，什么地方，做什么增强！</strong></li><li>织入（Weaving）<br>把切面加入到对象，并创建出代理对象的过程。（由 Spring 来完成）</li></ul><h4 id="AOP-编程"><a href="#AOP-编程" class="headerlink" title="AOP 编程"></a>AOP 编程</h4><ol><li>在 Packge【service】下创建 【ProductService】类：</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProductService</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomeService</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"doSomeService"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>在 xml 文件中装配该 bean：</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">name</span>=<span class="string">"productService"</span> <span class="attr">class</span>=<span class="string">"service.ProductService"</span> /&gt;</span></span><br></pre></td></tr></table></figure><ol><li><p>在【TestSpring】中编写测试代码</p></li><li><p>在 Packge【aspect】下准备日志切面 【LoggerAspect】类：</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.kgc.springtest2.demo1.logger;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> cn.kgc.springtest2.demo1.service.impl.IUserServiceImpl;</span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"><span class="keyword">import</span> org.apache.log4j.Logger;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.JoinPoint;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.AfterReturning;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.Before;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> zaizai</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2019/7/31 17:30</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServiceLogger</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger log=Logger.getLogger(IUserServiceImpl.class);</span><br><span class="line"><span class="meta">@AfterReturning</span>()</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterThowing</span><span class="params">(RuntimeException e)</span></span>&#123;</span><br><span class="line">      log.error(<span class="string">"我们检测到了报错情况，报错信息如下"</span>+e.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Before</span>(<span class="string">"execution(* cn.kgc.springtest2.demo1.service.IUserServiceImpl.*(..))"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">(JoinPoint jp)</span></span>&#123;</span><br><span class="line">        log.info(<span class="string">"调用"</span>+jp.getTarget());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">after</span><span class="params">()</span></span>&#123;</span><br><span class="line">        log.info(<span class="string">"无论上面有没有报错，这都会运行"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>在 xml 文件中声明业务对象和日志切面：</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span> <span class="attr">xmlns:aop</span>=<span class="string">"http://www.springframework.org/schema/aop"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">"http://www.springframework.org/schema/context"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">"cn.kgc.springtest2.demo1.service,cn.kgc.springtest2.demo1.dao"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"dao"</span> <span class="attr">class</span>=<span class="string">"cn.kgc.springtest2.demo1.dao.impl.UserDaoImpl"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"service"</span> <span class="attr">class</span>=<span class="string">"cn.kgc.springtest2.demo1.service.impl.IUserServiceImpl"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">"userDao"</span> <span class="attr">ref</span>=<span class="string">"dao"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"logger"</span> <span class="attr">class</span>=<span class="string">"cn.kgc.springtest2.demo1.logger.ServiceLogger"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:aspect</span> <span class="attr">ref</span>=<span class="string">"logger"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">id</span>=<span class="string">"pointcut"</span> <span class="attr">expression</span>=<span class="string">"execution(* cn.kgc.springtest2.demo1.service..*(..))"</span>/&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--     如果目标方法发生了异常,将会走此方法       --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">aop:after-throwing</span> <span class="attr">method</span>=<span class="string">"afterThowing"</span> <span class="attr">pointcut-ref</span>=<span class="string">"pointcut"</span> <span class="attr">throwing</span>=<span class="string">"e"</span>/&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--      无论如何都会执行      --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">aop:after</span> <span class="attr">method</span>=<span class="string">"after"</span> <span class="attr">pointcut-ref</span>=<span class="string">"pointcut"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">aop:aspect</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><ol><li>再次运行 TestSpring 中的测试代码，代码并没有改变，但是在业务方法运行之前和运行之后，都分别输出了日志信息：</li></ol><p><img src="http://ww.zai1999.club/img/spring/spring-cw.png" alt="img" data-src="http://ww.zai1999.club/img/spring/spring-cw.png" class="lazyload"></p><p>参考来自：<a href="https://www.cnblogs.com/wmyskxz/p/8820371.html" target="_blank" rel="noopener">https://www.cnblogs.com/wmyskxz/p/8820371.html</a></p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
          <category> spring框架 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> spring框架 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>娱乐不再想到头秃</title>
      <link href="/2019/07/31/%E5%8F%91%E5%9B%BE%E4%B8%8D%E5%86%8D%E6%83%B3%E5%88%B0%E5%A4%B4%E7%A7%83/"/>
      <url>/2019/07/31/%E5%8F%91%E5%9B%BE%E4%B8%8D%E5%86%8D%E6%83%B3%E5%88%B0%E5%A4%B4%E7%A7%83/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>1.（娱乐中）。。。。。。。。。。。。。。。。。。。。</p><p>2.**你喜欢我吗，如果你喜欢我的话，你就活着。</p><p><strong>3.</strong>世界上最危险的事莫过于把闹钟关掉后又闭上了眼睛 ，这是目前人类唯一可实行的穿越方法，闭眼5秒钟就能抵达2个小时后的未来。</p><p><strong>4.</strong>有一句话，宾语是你。吉下两点一口，又有欠字相依。（翻译过来：喜欢你）</p><p><strong>5.**</strong>你摸摸我衣服的料子，是不是做你女朋友的料。**</p><p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/oibtwfezaTqOCe4lEaYx6iaDaTGW0BsWQib0e5icibpZ6SMWsicB5D7wPjPeEIhtMlKNhUCYxYR7iats8ic4iaicWKpGN51w/640?wx_fmt=jpeg" alt="img" data-src="https://mmbiz.qpic.cn/mmbiz_jpg/oibtwfezaTqOCe4lEaYx6iaDaTGW0BsWQib0e5icibpZ6SMWsicB5D7wPjPeEIhtMlKNhUCYxYR7iats8ic4iaicWKpGN51w/640?wx_fmt=jpeg" class="lazyload"></p><p><strong>6.</strong>我喜欢的人多了，你算老大。</p><p><strong>7.</strong>你总是在深夜流泪，想着我这个你泡不到的妹。</p><p><strong>8.**</strong>人间不正经生活手册**。</p><p><strong>9.</strong>喜欢我的扣1，不喜欢我的扣眼珠子。</p><p><strong>10.</strong>这不是肉，这是爸爸的钱和妈妈的爱。</p><p><strong>11.</strong>我怀疑你是我的男朋友，但我没有证据。</p><p><strong>12.</strong>我小时候有个梦想，长大了要超有钱，现在梦想实现一半了，我长大了。</p><p><strong>13.</strong>大家好，我也是微商 ，我贩卖的主要产品是我的美貌与才华。</p><p><strong>14.**</strong>盐于律己，甜以待人**。</p><p><strong>15.</strong>你知不知道每当鲸鱼拉屎的时候，它的屁股要张开很大，拉完之后久久不能闭合，非常痛苦。你不知道，因为你只在乎你自己。</p><p><strong>16.</strong>无语，睡觉门槛真高，还得闭上眼，不然睡不着。</p><p><strong>17.</strong>人类真可爱，问我晚上不睡觉都在干嘛，还能干嘛 ，当然是想着怎么联系外星人炸地球。</p><p><strong>18.**</strong>今日限定 ，本人全糖去冰**。</p><p><strong>19.</strong>真想在我的肚子上贴个表情：公共场合禁止咕噜叫。</p><p><strong>20.</strong>抽一个人跟我谈恋爱，没别的，让你体会什么是人生不幸 什么是情感厄运。</p><p><strong>21.</strong>地球不太好混，我要去自闭星球。</p><p><strong>22.</strong>别心急，那个在被窝里储存许多屁味儿送给你的人会来的。</p><p><strong>23.</strong>哎生活真不容易，我要叹口气 O~</p><p><strong>24.</strong>每天我都是三好学生，好饿，好累，好想睡。</p><p><strong>25.</strong>上了生活的贼船，就做个快乐的海盗。</p><p><strong>26.</strong>我已经盖好被子了 ꍞ(:˒[▓︎▓︎] 就等你说晚安了。</p><p><strong>27.</strong>警察叔叔!这里有个男孩我拿不下!</p><p><strong>28.</strong>想不想把我的肚子搞大？v我20 买杯奶茶。</p><p><strong>29.</strong>你家也太穷了吧，想去你家，你居然和我说门都没有。</p><p><strong>30.**</strong>天要再这么热下去，恐怕我冰淇淋的身份就要曝光了**。</p><p><strong>31.</strong>你的眼睛里很干净，没有杂质也没有我。</p><p><strong>32.</strong>_=͟͟͞͞(๑•̀=͟͟͞͞(๑•̀д•́=͟͟͞͞(๑•̀д•́๑)冲冲冲。</p><p><strong><em>33.</em></strong>你们要注意一下啦，不要被我的可爱冲昏了头脑。</p><p><strong><em>34.</em></strong>月亮不睡，我不睡，太阳起了，我不起。</p><p><strong><em>35.</em></strong>我已经不是那个什么事都拜托星星的女孩啦。</p><p><strong>36.</strong>有人吼了我，八小时之后我还在回想这件事。</p><p><strong><em>37.**</em></strong>物极必反，人美必单**。</p><p><strong><em>38.</em></strong>关于我的事你还是听我的版本好一点。</p><p><strong><em>39.</em></strong>你的眼神再温柔些 ，月亮会融化，我也会。</p><p><strong><em>40.</em></strong>达则兼济天下，穷则不点奶茶。</p><p><strong><em>41.</em></strong>既然你不喜欢我(.<em>.)，那我就gun了哦，  ( l: )我真的gun了哦，( .-. ) ( :l ) (.</em>.) ( l: )( .-. ) ( :l ) (.<em>.) ( l: )( .-. ) ( :l ) (.</em>.) ( l: )( .-. ) ( :l ) (.<em>.) ( l: )( .-. ) ( :l ) (.</em>.) ( l: )( .-. ) ( :l ) (.<em>.) ( l: )( .-. ) ( :l ) (.</em>.) ( l: )( .-. )</p><p><strong><em>42.</em></strong>这个世界乱糟糟的，而你干干净净，可以悬在我的心上，作太阳和月亮。</p><p><strong><em>43.</em></strong>我野蛮生长 没能成为自己的月亮，能遇见你，是银河赠送我的糖。</p><p><strong><em>44.</em></strong>请你一定要对号入座，我说的所有星光月亮，清泉小溪，蘸着糖的奶油和蜂蜜，这世间所有的美好事物，都只是为了形容你。</p><p><strong>45.</strong>你是个可爱又浪漫的麻烦。</p><p><strong><em>46.</em></strong>你难道看不出来我对你起了贼心了吗？</p><p><strong><em>47.**</em></strong>你不是怀念过去，你只是现在过的不好**。</p><p><strong><em>48.</em></strong>这是一条甜甜圈，请查收。</p><p><strong><em>49.</em></strong>马上要恋爱啦！和谁还不知道 我先替他高兴一下！</p><p><strong>50.</strong>如果我是一只蝴蝶；那么我有一个美丽的名字：沃斯尼蝶。</p><p><strong><em>51.</em></strong>平凡至极又可爱非常。</p><p><strong><em>52.</em></strong>生死有命，胖瘦在天。</p><p><strong><em>53.**</em></strong>我对你图谋不轨有一会儿了**。</p><p><strong><em>54.</em></strong>可爱之人必有可爱之处。</p><p><strong><em>55.</em></strong>美籍华人算什么，我可是华籍美人。</p><p><strong><em>56.</em></strong>刚才我翻一个女孩子空间，翻着翻着就爱上了。觉得她太可爱了，退出来准备看看是谁，一看是我自己，不好意思。</p><p><strong><em>57.</em></strong>有一天下午我百无聊赖实在找不到事做，我就决定干脆喜欢你好了，反正闲着也是闲着。 </p><p><strong><em>58.**</em></strong>我是一条酸菜鱼 又酸又菜有多余。**</p><p><strong>59.</strong>我对象说明天来见我。象：不行！~</p><p><strong><em>60.</em></strong>「今でもあなたは私の光」如今你依旧是我的光。</p><p><strong><em>61.</em></strong>玩游戏sorry全场的我来了。</p><p><strong><em>62.</em></strong> 当你觉得不行的时候，走到斑马线上，你就会变成一个行人。</p><p><strong><em>63.</em></strong>我是一台复读机，但我从未说过我爱你，因为没听过所以无法复读。</p><p><strong>64.**</strong>世界上原本没有公主，直到我出现。**</p><p><strong><em>65.</em></strong>不要好奇我是谁，也不要问我要备注，我，该死的美女。</p><p><strong><em>66.</em></strong>所有好看的照片都是我p的，还有那些不好看的照片都是我p失败的。</p><p><strong><em>67.</em></strong>我们复合吧，我想你了，这个赛季太难打了。</p><p><strong><em>68.</em></strong>我在茫茫人海中一眼认出了你，从此我便多了一个外号：知猪侠。</p><p><strong><em>69.**</em></strong>怎么泡男孩子呀，水温多少合适啊**。</p><p><strong><em>70.</em></strong> 爸妈让我过年把男朋友带回家。我说；不好吧，一屋子坐不下。</p><p><strong><em>71.</em></strong> <strong>想问问你现在几点，也没别的意思，就是提醒你不早了 也该喜欢我了。</strong></p><p><strong><em>72.</em></strong>“如果夜里不能吃东西，那冰箱里为什么会有灯呢？”</p><p><strong><em>73.</em></strong>我饿了，果然诚实可靠幽默风趣温柔善良正义体贴可爱单纯天真浪漫大方有趣灵巧热情甜美典雅优雅美丽不能当饭吃。</p><p><strong><em>74.</em></strong>今天我又拒绝了五个男人，看着他们落寞的眼神，远去的身影，我只能默默的说声抱歉，虽然天这么热，但我真的打不起车了，我走路</p>]]></content>
      
      
      <categories>
          
          <category> 业余 </category>
          
          <category> 娱乐 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 娱乐 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo文章写法</title>
      <link href="/2019/07/31/hexo%E6%96%87%E7%AB%A0%E5%86%99%E6%B3%95/"/>
      <url>/2019/07/31/hexo%E6%96%87%E7%AB%A0%E5%86%99%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="hexo的文章编写法"><a href="#hexo的文章编写法" class="headerlink" title="hexo的文章编写法"></a>hexo的文章编写法</h1><h2 id="一、创建文章"><a href="#一、创建文章" class="headerlink" title="一、创建文章"></a>一、创建文章</h2><p>在站点文件夹中打开 git bash，输入如下命令创建文章，其中 title 为文章的标题</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new &quot;title&quot;</span><br><span class="line">当输入命令后，就会在 source/_post 文件夹下创建一个文件，命名为：title.md</span><br></pre></td></tr></table></figure><p>这个文件就是将要发布到网站上的原始文件，用于记录文章内容</p><p>下面，我们将要在这个文件中写下我们的第一篇博客</p><h2 id="二、编写文章（基于-Markdown）"><a href="#二、编写文章（基于-Markdown）" class="headerlink" title="二、编写文章（基于 Markdown）"></a>二、编写文章（基于 Markdown）</h2><h4 id="1、Markdown-简介"><a href="#1、Markdown-简介" class="headerlink" title="1、Markdown 简介"></a>1、Markdown 简介</h4><p>但是，在我们正式写下第一个文字前，我们需要了解一下究竟什么是 Markdown？</p><p>Markdown 是一种可以使用普通文本编辑器编写的 标记语言，通过简单的 标记语法，它可以使普通文本内容具有一定的格式</p><p>基于 Markdown 语法的简洁性，它已经成为目前世界上最流行的用于书写博客的语言</p><h4 id="2、Markdown-语法"><a href="#2、Markdown-语法" class="headerlink" title="2、Markdown 语法"></a>2、Markdown 语法</h4><p>在编写 Markdown 时，博主强烈的推荐给大家一款简洁易用的 Markdown 编辑器 —— Typora</p><p>按照官方的说法就是 简单而强大，它不仅支持原生的语法，也支持对应的快捷键，更重要的是它还可以 实时预览</p><p>这里附上 Typora 的下载地址：<a href="https://www.typora.io/，有兴趣的朋友可以下载来试试" target="_blank" rel="noopener">https://www.typora.io/，有兴趣的朋友可以下载来试试</a></p><p>好，下面开始进入正题，介绍一些常用的 Markdown 语法</p><h5 id="（1）标题"><a href="#（1）标题" class="headerlink" title="（1）标题"></a>（1）标题</h5><p>Markdown 语法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># 一级标题</span><br><span class="line"></span><br><span class="line">## 二级标题</span><br><span class="line"></span><br><span class="line">### 三级标题</span><br><span class="line"></span><br><span class="line">#### 四级标题</span><br><span class="line"></span><br><span class="line">##### 五级标题</span><br><span class="line"></span><br><span class="line">###### 六级标题</span><br></pre></td></tr></table></figure><p>Typora 快捷键：</p><p>Ctrl+1：一级标题</p><p>Ctrl+2：二级标题</p><p>Ctrl+3：三级标题</p><p>Ctrl+4：四级标题</p><p>Ctrl+5：五级标题</p><p>Ctrl+6 ：六级标题</p><p>Ctrl+0：段落</p><h5 id="（2）粗体、斜体、删除线和下划线"><a href="#（2）粗体、斜体、删除线和下划线" class="headerlink" title="（2）粗体、斜体、删除线和下划线"></a>（2）粗体、斜体、删除线和下划线</h5><p>Markdown 语法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">*斜体*</span><br><span class="line">**粗体**</span><br><span class="line">***加粗斜体***</span><br><span class="line">~~删除线</span><br></pre></td></tr></table></figure><p>~~</p><p>Typora 快捷键：</p><p>Ctrl+I：斜体</p><p>Ctrl+B：粗体</p><p>Ctrl+U：下划线</p><p>Alt+Shift+5：删除线</p><h5 id="（3）引用块"><a href="#（3）引用块" class="headerlink" title="（3）引用块"></a>（3）引用块</h5><p>Markdown 语法：</p><blockquote><p>文字引用<br>1<br>Typora 快捷键： Ctrl+Shift+Q</p></blockquote><h5 id="（4）代码块"><a href="#（4）代码块" class="headerlink" title="（4）代码块"></a>（4）代码块</h5><p>Markdown 语法：</p><p><code>行内代码</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">多行代码</span><br><span class="line">多行代码</span><br></pre></td></tr></table></figure><p>Typora 快捷键：</p><p>行内代码：Ctrl+Shift+`</p><p>多行代码：Ctrl+Shift+K</p><h5 id="（5）公式块"><a href="#（5）公式块" class="headerlink" title="（5）公式块"></a>（5）公式块</h5><p>Markdown 语法：<br>$$<br>数学公式<br>Typora 快捷键： Ctrl+Shift+M<br>$$</p><h5 id="（6）分割线"><a href="#（6）分割线" class="headerlink" title="（6）分割线"></a>（6）分割线</h5><p>Markdown 语法：</p><p>方法一：—</p><p>方法二：+++</p><p>方法三：***</p><h5 id="（7）列表"><a href="#（7）列表" class="headerlink" title="（7）列表"></a>（7）列表</h5><p>Markdown 语法：</p><ol><li>有序列表项</li></ol><ul><li>无序列表项</li></ul><ul><li>无序列表项</li></ul><ul><li>无序列表项</li></ul><p>Typora 快捷键：</p><p>有序列表项：Ctrl+Shift+[</p><p>无序列表项：Ctrl+Shift+]</p><h5 id="（8）表格"><a href="#（8）表格" class="headerlink" title="（8）表格"></a>（8）表格</h5><p>Markdown 语法：</p><table><thead><tr><th>表头1</th><th>表头2</th></tr></thead><tbody><tr><td>内容11</td><td>内容12</td></tr><tr><td>内容21</td><td>内容22</td></tr></tbody></table><p>Typora 快捷键： Ctrl+T</p><h5 id="（9）超链接"><a href="#（9）超链接" class="headerlink" title="（9）超链接"></a>（9）超链接</h5><p>Markdown语法：</p><p>方法一：<a href="链接地址" title="链接描述">链接文字</a><br>例如：<a href="https://www.zai1999.club/" title="示例链接">示例链接</a></p><p>方法二：&lt;链接地址&gt;<br>例如：<a href="https://www.zai1999.club/">https://www.zai1999.club/</a></p><p>Typora快捷键： Ctrl+K</p><h5 id="（10）图片"><a href="#（10）图片" class="headerlink" title="（10）图片"></a>（10）图片</h5><p>Markdown语法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">![图片文字](图片地址 &quot;图片描述&quot;)</span><br></pre></td></tr></table></figure><p>Typora快捷键： Ctrl+Shift+I</p><p>Typora快捷键： Ctrl+Shift+I</p><p>说明：在 Hexo中 插入图片时，请按照以下的步骤进行设置</p><p>将 站点配置文件 中的 post_asset_folde 选项的值设置为 true</p><p>在站点文件夹中打开 git bash，输入命令 npm install hexo-asset-image –save 安装插件</p><p>这样，当使用 hexo new title 创建文章时，将同时在 source/_post 文件夹中生成一个与 title 同名的文件夹，我们只需将图片放进此文件夹中，然后在文章中通过 Markdown 语法进行引用即可</p><h4 id="3、高级设置"><a href="#3、高级设置" class="headerlink" title="3、高级设置"></a>3、高级设置</h4><h5 id="（1）模板设置"><a href="#（1）模板设置" class="headerlink" title="（1）模板设置"></a>（1）模板设置</h5><p>当我们使用命令 hexo new “title” 创建文章时，Hexo 会根据 /scaffolds/post.md 对新文章进行初始化</p><p>换言之，/scaffolds/post.md 就是新文章的 模板，所以我们可以修改它来适应自己的写作习惯</p><p>一个简单的示例如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">title: &#123;&#123; title &#125;&#125;</span><br><span class="line">date: &#123;&#123; date &#125;&#125;</span><br><span class="line">tags: </span><br><span class="line">categories:</span><br></pre></td></tr></table></figure><h5 id="（2）头部设置"><a href="#（2）头部设置" class="headerlink" title="（2）头部设置"></a>（2）头部设置</h5><p>在每篇利用 Hexo 创建的文章的开头，都会有对文章进行说明的文字，叫做 文章头部</p><p>（2）头部设置<br>在每篇利用 Hexo 创建的文章的开头，都会有对文章进行说明的文字，叫做 文章头部</p><p>文章的头部除了可以设置文章标题、发布日期等基础信息外，还可以为文章添加标签、分类等</p><p>一个简单的示例如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">title: Title</span><br><span class="line">date: YYYY-MM-DD HH:MM:SS</span><br><span class="line">tags: [tag1, tag2, ...]</span><br><span class="line">categories: category</span><br></pre></td></tr></table></figure><p>注意：属性和属性值之间必须有一个空格，否则会解析错误</p><p>注意：属性和属性值之间必须有一个空格，否则会解析错误</p><h5 id="（3）首页显示"><a href="#（3）首页显示" class="headerlink" title="（3）首页显示"></a>（3）首页显示</h5><p>在利用 Hexo 框架搭建的博客网站中，首页会显示文章的内容，且默认显示文章的全部内容</p><p>如果当文章太长的时候就会显得十分冗余，所以我们有必要对其进行精简</p><h6 id="这时，我们只需在文章中使用-标志即可，表示只会显示标志前面的内容"><a href="#这时，我们只需在文章中使用-标志即可，表示只会显示标志前面的内容" class="headerlink" title="这时，我们只需在文章中使用  标志即可，表示只会显示标志前面的内容"></a>这时，我们只需在文章中使用 <a id="more"></a> 标志即可，表示只会显示标志前面的内容</h6><p>参考来自：<a href="https://blog.csdn.net/wsmrzx/article/details/81478945" target="_blank" rel="noopener">https://blog.csdn.net/wsmrzx/article/details/81478945</a> </p>]]></content>
      
      
      <categories>
          
          <category> 博客 </category>
          
          <category> HEXO文章写法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HEXO文章写法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>致&#39;天生没什么运气的我们&#39;</title>
      <link href="/2019/07/29/%E8%87%B4-%E5%A4%A9%E7%94%9F%E6%B2%A1%E4%BB%80%E4%B9%88%E8%BF%90%E6%B0%94%E7%9A%84%E6%88%91%E4%BB%AC/"/>
      <url>/2019/07/29/%E8%87%B4-%E5%A4%A9%E7%94%9F%E6%B2%A1%E4%BB%80%E4%B9%88%E8%BF%90%E6%B0%94%E7%9A%84%E6%88%91%E4%BB%AC/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="致’天生没什么运气的我们’"><a href="#致’天生没什么运气的我们’" class="headerlink" title="致’天生没什么运气的我们’"></a>致’天生没什么运气的我们’</h2><p>  有人说，运气就像一个独立的宇宙，你不知道它是好是坏，更不知道何时与你擦肩而过。对于这个性情怪异、难以捉摸的家伙，常常觉得找不到什么更好的办法去面对它。</p><p>但也有人说，“运气是强者的自谦、弱者的借口”。运气是一个任人打扮的小姑娘，看不到摸不着，你说是啥就是啥。</p><p>“天生没什么运气的我们”这个群里的人，都是假装世界上从来没有发明过“运气”这个词。</p><p>当遇到不好的事情，首先想想是不是自己不够努力、预判不足、贪心、能力欠缺……缺啥补啥，跟霉运无关；当遇到好事儿，也会开心地认为可能是足够努力、判断准确、对人友好、能力强……一分耕耘一分收获，跟好运无关。</p><p>如果一个任务摆在你面前，你不会再把它完全交给所谓的“运气”，而是分步骤考虑如何实施，你会发现天高地阔，人生的效率明显提高。  </p><p>读过墨菲定律的人知道：如果事情有变坏的可能，不管这种可能性有多小，它总会发生。</p><p>定律：</p><p><strong>墨菲定律（Murphy’s Law）</strong>主要内容有四个方面：</p><p>一、任何事都没有表面看起来那么简单；</p><p>二、所有的事都会比你预计的时间长；</p><p>三、会出错的事总会出错；</p><p>四、如果你担心某种情况发生，那么它就更有可能发生。</p><p>“墨菲定律”的根本内容是“凡是可能出错的事有很大几率会出错”，指的是任何一个事件，只要具有大于零的机率，就不能够假设它不会发生。 </p><p>与“good luck”相比，我觉得“天生没什么运气的我们”更励志。因为天生没什么运气，就不会去指望天降好运，只会一点点去经营自己的生活，一点点去完善自己的人格。钱要一点点地赚，远离为你画馅饼的人；路要一步步走，与其相信风口，不如相信时间。</p><p>之前每天起床第一件事会去看qq的星座运势，看完如果运气很好的话，会去买几个彩票，当然也没怎么中过，这相当于想着走捷径，想着靠着自己的运气过着，运气不可能伴随着我们一辈子，只可能让我们相信时一败涂地，这几天看了一个电影《<a href="http://www.baidu.com/link?url=YFIQQa5aqDMuJl8GG0cH45OLK-aDCzlvRLdweklIbbopTB5XWHKXaPEgsuXWziDBAK0z_CO44J4oBsqvHX7Sl_" target="_blank" rel="noopener"><em>哪吒</em>之魔童降世</a>》当中有一句话：“若命运不公，我便和他斗到底。”,是的，靠努力获得的成果，比运气获得的美好的更多。</p><p>与“<strong>good luck</strong>”相比，我觉得“<strong>天生没什么运气的我们</strong>”更励志。因为天生没什么运气，就不会去指望天降好运，只会一点点去经营自己的生活，一点点去完善自己的人格。钱要一点点地赚，远离为你画馅饼的人；路要一步步走，与其相信风口，不如相信时间。</p><p>  生命的果实，是逐渐复制和累积的过程。成功之后，分析成功的步骤，才可能复制另一次成功；失败之后，复盘失败的原因，才可能避免同样的失败。</p><p>这才是每一步都算数。</p><p><strong>其实这世界上许多人，都是“天生没什么运气的我们”，有时顺风顺水，有时路遇险阻。但无论什么时候，人生的三板斧无非是接纳、解决与放下，不然还能怎样？</strong></p><p>那些打不倒我们的，终会让我们更加强大。  </p><p>读来《人民网夜读》</p>]]></content>
      
      
      <categories>
          
          <category> 业余 </category>
          
          <category> 阅读 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 阅读 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>搭建属于自己的博客</title>
      <link href="/2019/07/24/%E6%90%AD%E5%BB%BA%E5%B1%9E%E4%BA%8E%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2/"/>
      <url>/2019/07/24/%E6%90%AD%E5%BB%BA%E5%B1%9E%E4%BA%8E%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="搭建属于自己的博客"><a href="#搭建属于自己的博客" class="headerlink" title="搭建属于自己的博客"></a>搭建属于自己的博客</h3><p>首先来说一个<strong>博客的重要性</strong>：</p><p>个人学习中，被动接受时较容易接受，其实博主赞成自学，自己琢磨的东西对思维及其逻辑明显高于被动接受的，在将我们的知识和理解传达给他人，这种方式对自己的提升无疑是非常大的。</p><p>可能博主我比较啰嗦，我还是想说博客对于技术人员非常重要。</p><p>框架的选择还有很多种推荐几个流行的Blog框架：</p><ul><li><p><a href="https://jekyllrb.com/" target="_blank" rel="noopener">Jekyll</a> </p></li><li><p><a href="http://www.gohugo.org/" target="_blank" rel="noopener">hugo</a> </p></li><li><p><a href="https://www.djangoproject.com/" target="_blank" rel="noopener">django</a> </p></li><li><p><a href="https://hexo.io/" target="_blank" rel="noopener">hexo</a> </p><p>来一个基础既简单方便的博客框架<a href="http://www.zai1999.club/2019/07/21/%E5%AF%B9%E4%BA%8EHEXO%E4%BB%8B%E7%BB%8D/">hexo</a>，对于初学者来说hexo还是很方便快捷的。</p></li></ul><h1 id="一、开篇"><a href="#一、开篇" class="headerlink" title="一、开篇"></a>一、开篇</h1><p>如需要把自己的博客公开的话，需要有自己的服务器，及域名。</p><p>首先服务器的话博主推荐：<a href="https://cloud.tencent.com/act/campus?fromSource=gwzcw.1293314.1293314.1293314&cps_key=431fc56be57d892cc2d064e86028022b" target="_blank" rel="noopener">腾讯云</a>或者<a href="https://promotion.aliyun.com/ntms/act/campus2018.html?spm=5176.10695662.1244717.1.3b50640fHEWwRU" target="_blank" rel="noopener">阿里云</a>等的学生服务器，便宜啊！！购买最长一年(推荐),因为续费的话最多续费2次，也就是说总共有3年，后面就贵及了。如果想长期用的话推荐国外的<img src="file:///C:%5CUsers%5Cadmin%5CAppData%5CLocal%5CTemp%5CSGPicFaceTpBq%5C21964%5C4FA5F577.png" alt="img" data-src="file:///C:%5CUsers%5Cadmin%5CAppData%5CLocal%5CTemp%5CSGPicFaceTpBq%5C21964%5C4FA5F577.png" class="lazyload"></p><p>域名和服务器一样新用户便宜后期感觉都很坑：<a href="https://wanwang.aliyun.com/domain/com/?spm=5176.10695662.1158081.1.59854234dk4O0M" target="_blank" rel="noopener">阿里</a>和<a href="https://cloud.baidu.com/product/bcd.html" target="_blank" rel="noopener">百度</a>、还有<a href="https://dnspod.cloud.tencent.com/" target="_blank" rel="noopener">腾讯</a>等。</p><p>这里温馨提示一下域名购买很快，域名如想被搜索到需要进行备案。（等待的时间很漫长的记得当时博主申请时有了半个月）。</p><p>服务器购买后安装系统时有需要选择服务器的系统，这里推荐Linux的CoreOS版的轻量方便，若装windows系统的话网站加载不如Linux的快，吃过亏的。Linux的服务器使用Xshell连接就好<img src alt data-src class="lazyload">，Windows系统的直接Windows键加R输入MSTSC<img src alt data-src class="lazyload"></p><p>在购买的网站上找到自己服务器的外网连接就好</p><p>如博主的<img src alt data-src class="lazyload"></p><p>Linux的连接成功<img src="http://www.zai1999.club/img/hexodajian/Linux-lian.png" alt data-src="http://www.zai1999.club/img/hexodajian/Linux-lian.png" class="lazyload"></p><p>Windows的要记得打开外网开放端口，不会请百度一下</p><h3 id="不想用服务器只在本机安装的从这里开始"><a href="#不想用服务器只在本机安装的从这里开始" class="headerlink" title="不想用服务器只在本机安装的从这里开始"></a>不想用服务器只在本机安装的从这里开始</h3><p><a href="http://www.zai1999.club/2019/07/21/%E5%AF%B9%E4%BA%8EHEXO%E4%BB%8B%E7%BB%8D/">windows参考</a></p><h5 id="安装HEXO前提要安装"><a href="#安装HEXO前提要安装" class="headerlink" title="安装HEXO前提要安装:"></a>安装HEXO前提要安装:</h5><ul><li><a href="http://nodejs.org/" target="_blank" rel="noopener">Node.js</a> (Should be at least nodejs 6.9)</li><li><a href="http://git-scm.com/" target="_blank" rel="noopener">Git</a></li></ul><p>Windows我后面不做介绍了，因为跟本机一样</p><h6 id="首先安装Node-js"><a href="#首先安装Node-js" class="headerlink" title="首先安装Node.js"></a>首先安装Node.js</h6><p>1.通过  uname -a  命令查看到我的Linux系统位数是64位（备注：x86_64表示64位系统， i686 i386表示32位系统），如图</p><p><img src="http://www.zai1999.club/img/hexodajian/Linux-name.png" alt data-src="http://www.zai1999.club/img/hexodajian/Linux-name.png" class="lazyload"></p><p>2.下载标注的</p><p><img src="http://www.zai1999.club/img/hexodajian/Linux-xiaNode.png" alt data-src="http://www.zai1999.club/img/hexodajian/Linux-xiaNode.png" class="lazyload"></p><p>3.下载下来的tar文件上传到服务器并且解压，然后通过建立软连接变为全局；</p><p>1）上传服务器可以是自己任意路径，目前我的放置路径为  cd /MyAPP/nodes/</p><p><strong>注意：去看一下Linux常用命令</strong></p><p>2）解压上传  注意要改名字解压（解压后的文件我这边将名字改为了nodejs，这个地方自己随意，只要在建立软连接的时候写正确就可以）</p><p>①</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -xvf   node-v6.10.0-linux-x64.tar.xz</span><br></pre></td></tr></table></figure><p>   ②</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mv node-v6.10.0-linux-x64  nodejs</span><br></pre></td></tr></table></figure><p> ③确认一下nodejs下bin目录是否有node 和npm文件，如果有执行软连接，如果没有重新下载执行上边步骤；</p><p>3）建立软连接，变为全局</p><p>   ①ln -s /app/software/nodejs/bin/npm /usr/local/bin/ </p><p>   ②ln -s /app/software/nodejs/bin/node /usr/local/bin/</p><p>4）最后一步检验nodejs是否已变为全局</p><p>   在Linux命令行node -v 命令会显示nodejs版本</p><h6 id="安装Git：参考廖雪峰"><a href="#安装Git：参考廖雪峰" class="headerlink" title="安装Git：参考廖雪峰"></a>安装Git：参考<a href="https://www.liaoxuefeng.com/wiki/896043488029600/896067074338496" target="_blank" rel="noopener">廖雪峰</a></h6><p>首先，你可以试着输入<code>git</code>，看看系统有没有安装Git：</p><p>博主这个Linux版本自带了Git</p><p>没有Git的话</p><p>如果你碰巧用Debian或Ubuntu Linux，通过一条<code>sudo apt-get install git</code>就可以直接完成Git的安装，非常简单。</p><p>老一点的Debian或Ubuntu Linux，要把命令改为<code>sudo apt-get install git-core</code>，因为以前有个软件也叫GIT（GNU Interactive Tools），结果Git就只能叫<code>git-core</code>了。由于Git名气实在太大，后来就把GNU Interactive Tools改成<code>gnuit</code>，<code>git-core</code>正式改为<code>git</code>。</p><p>如果是其他Linux版本，可以直接通过源码安装。先从Git官网下载源码，然后解压，依次输入：<code>./config</code>，<code>make</code>，<code>sudo make install</code>这几个命令安装就好了。</p><h6 id="安装Hexo："><a href="#安装Hexo：" class="headerlink" title="安装Hexo："></a>安装Hexo：</h6><p>有了以上的必备可以进行下一步</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`$ npm install -g hexo-cli`</span><br></pre></td></tr></table></figure><p>安装 Hexo 完成后，请执行下列命令，Hexo 将会在指定文件夹中新建所需要的文件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ hexo init &lt;folder&gt;  //这是新建一个hexo的文件夹</span><br><span class="line">$ cd &lt;folder&gt;  //打开此文件</span><br><span class="line">$ npm install</span><br></pre></td></tr></table></figure><p>新建完成后，指定文件夹的目录如下：</p><p><img src="http://www.zai1999.club/img/hexodajian/hexo-mulu.png" alt data-src="http://www.zai1999.club/img/hexodajian/hexo-mulu.png" class="lazyload"></p><p>默认生成的有一个</p><p>HelloWord的然后我们cmd命令后输入hexo g是发布，然后hexo s运行</p><p><img src="http://www.zai1999.club/img/hexodajian/bushutu.jpg" alt data-src="http://www.zai1999.club/img/hexodajian/bushutu.jpg" class="lazyload"></p>]]></content>
      
      
      <categories>
          
          <category> 业余 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> -搭建博客 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面试题-1</title>
      <link href="/2019/07/23/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
      <url>/2019/07/23/%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="一-lbatis和Mybatis的"><a href="#一-lbatis和Mybatis的" class="headerlink" title="一.lbatis和Mybatis的?"></a>一.lbatis和Mybatis的?</h4><p>​    lbatis:<br>​        2010年,apache的lbatis框架停止更新,并移交给Google团队,同时更名为Mybatis,从2010年lbatis不再更新,<br>​        彻底称为一个孤儿框架,一个没人维护的框架注定被Mybatis拍在沙滩上.<br>​    Mybatis:<br>​        lbatis的升级版本</p><h4 id="二-Mybatis在核心处理类叫什么"><a href="#二-Mybatis在核心处理类叫什么" class="headerlink" title="二.Mybatis在核心处理类叫什么?"></a>二.Mybatis在核心处理类叫什么?</h4><p>​        SqlSession</p><h4 id="三-Mybatis的好处"><a href="#三-Mybatis的好处" class="headerlink" title="三.Mybatis的好处?"></a>三.Mybatis的好处?</h4><p>​    1.把SQL语句从java中独立出来<br>​    2.封装了底层的JDBC,API的调用,并且能够将结果集自动转换成javaBean对象,简化了java数据库编程的重复工作<br>​    3.自己编写SQL  语句,更加灵活<br>​    4.入参无需用对象封装(或者map封装),使用@Param注解</p><h4 id="四-Mybatis工作原理"><a href="#四-Mybatis工作原理" class="headerlink" title="四.Mybatis工作原理?"></a>四.Mybatis工作原理?</h4><p>​    1.通过SqlSessionFactoryBuilder从Mybatis-config.xml配置文件中构建出SqlSessionFactory<br>​    2.SqlSessionFactory开启一个SqlSession,通过SqlSession实例获得Mapper对象并且运行Mapper映射的Sql语句<br>​    3.完成数据库的CRUD操作和事务提交,关闭SqlSession </p><h4 id="五-和-的区别"><a href="#五-和-的区别" class="headerlink" title="五.${}和#{}的区别?"></a>五.${}和#{}的区别?</h4><p>​    #{}:用于字符串的拼接 #{}参数注入,在执行的过程中以 ? 拼接 可以有效的防止sql注入<br>​    ${}:预编译处理,把${}直接替换成变量的值,不做任何转换<br>​    总结:一般用#{}来进行列的代替</p><h4 id="六-模糊查询like语句该怎么写"><a href="#六-模糊查询like语句该怎么写" class="headerlink" title="六.模糊查询like语句该怎么写?"></a>六.模糊查询like语句该怎么写?</h4><p>​    1.name like”%”#{name}”%” #起到占位符的作用<br>​    2.name like’%${name}%’ $进行字符串的拼接,直接把传入的值,拼接上去<br>​    3.name like concat(concat(‘%’,#{username}),’%’))这是使用了concat进行字符串的连接,同时使用#占位<br>​    4.name like  CONCAT(‘%’,’${name}’,’%’)对表达式进行了简化,更方便.</p><h4 id="七-在mapper中如何传递多个参数"><a href="#七-在mapper中如何传递多个参数" class="headerlink" title="七.在mapper中如何传递多个参数?"></a>七.在mapper中如何传递多个参数?</h4><p>​    第1种：使用占位符的思想，在映射文件中使用#{0}，#{1}代表传递进来的第几个参数。<br>​    使用@param注解:来命名参数<br>​    第2种：使用Map集合作为参数来装载</p><h4 id="八-将sql语句硬编码到java代码中-如果修改sql语句-需要修改-java代码-重新编译-系统可维护性不高-设想如何解决"><a href="#八-将sql语句硬编码到java代码中-如果修改sql语句-需要修改-java代码-重新编译-系统可维护性不高-设想如何解决" class="headerlink" title="八.将sql语句硬编码到java代码中,如果修改sql语句,需要修改    java代码,重新编译,系统可维护性不高,设想如何解决?"></a>八.将sql语句硬编码到java代码中,如果修改sql语句,需要修改    java代码,重新编译,系统可维护性不高,设想如何解决?</h4><p> 能否将sql单独配置在配置文件中?<br>   可以将 sql 语句配置在 xml 配置文件中，即使 sql 语句发生变化，也不需要重新编译 java 代码。 </p><h4 id="九-xml映射文件中-常见的select-insert-update-delete标签之外-还有哪些标签"><a href="#九-xml映射文件中-常见的select-insert-update-delete标签之外-还有哪些标签" class="headerlink" title="九.xml映射文件中,常见的select|insert|update|delete标签之外,还有哪些标签?"></a>九.xml映射文件中,常见的select|insert|update|delete标签之外,还有哪些标签?</h4><p>​    &lt;resultMap/parameterMap/sql/include/selectKey&gt;、动态sql 的9个标签[trim/where/set/foreach/if/choose/when/otherwise/bind—其中sql为sql片段标签，通过include标签引入sql片段，selectKey为不支持自增的主键生成策略标签]</p><h4 id="十-Mybatis能执行一对一-一对多的关联查询吗-都有哪些实现方式-以及它们之间的区别"><a href="#十-Mybatis能执行一对一-一对多的关联查询吗-都有哪些实现方式-以及它们之间的区别" class="headerlink" title="十.Mybatis能执行一对一.一对多的关联查询吗?都有哪些实现方式,以及它们之间的区别."></a>十.Mybatis能执行一对一.一对多的关联查询吗?都有哪些实现方式,以及它们之间的区别.</h4><p>​    能，Mybatis不仅可以执行一对一、一对多的关联查询，还可以执行多对一，多对多的关联查询，多对一查询，其实就是一对一查询，只需要把selectOne()修改为selectList()即可；多对多查询，其实就是一对多查询，只需要把selectOne()修改为selectList()即可。<br>​    </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">关联对象查询，有两种实现方式，一种是单独发送一个sql去查询关联对象，赋给主对象，然后返回主对象。另一种是使用嵌套查询，嵌套查询的含义为使用join查询，一部分列是A对象的属性值，另外一部分列是关联对象B的属性值，好处是只发一个sql\查询，就可以把主对象和其关联对象查出来。</span><br></pre></td></tr></table></figure><h4 id="十一-Mybatis的xml映射文件中-不同的xml映射文件-id是否可用重复"><a href="#十一-Mybatis的xml映射文件中-不同的xml映射文件-id是否可用重复" class="headerlink" title="十一.Mybatis的xml映射文件中,不同的xml映射文件,id是否可用重复?"></a>十一.Mybatis的xml映射文件中,不同的xml映射文件,id是否可用重复?</h4><p>​    如果配置了namespace那么当然是可以重复的，因为我们的Statement实际上就是namespace+id<br>如果没有配置namespace的话，那么相同的id就会导致覆盖了。</p><h4 id="十二-Spring在ssm中起什么作用"><a href="#十二-Spring在ssm中起什么作用" class="headerlink" title="十二.Spring在ssm中起什么作用"></a>十二.Spring在ssm中起什么作用</h4><p>​    Spring:轻量级框架<br>​    作用:Bean工厂,用来管理Bean的生命周期和框架集成<br>​    两大核心:<br>​        1.IOC/DI(控制反转/依赖注入):把dao依赖注入到service层,service层反转给action层,Spring顶层容器为BeanFactory<br>​        2.AOP:面向切面编程</p><h4 id="十三-Spring下的注解"><a href="#十三-Spring下的注解" class="headerlink" title="十三.Spring下的注解?"></a>十三.Spring下的注解?</h4><p>​    注册: @Controller @Service @Component<br>​    注入: @Autowired @Resource<br>​    请求地址: @RequestMappingk:<br>​    返回具体数据类型而非跳转: @ResponseBody</p><h4 id="十四-Spring-DI的方式"><a href="#十四-Spring-DI的方式" class="headerlink" title="十四.Spring DI的方式?"></a>十四.Spring DI的方式?</h4><p>​    构造器注入:通过构造方法初始化<br>​    setter方法注入:通过setter方法初始化<br>​     </p><h4 id="十五-IOC、AOP的实现原理"><a href="#十五-IOC、AOP的实现原理" class="headerlink" title="十五.IOC、AOP的实现原理?"></a>十五.IOC、AOP的实现原理?</h4><p>​    IOC: 通过反射机制生成对象注入<br>​    AOP: 动态代理</p><h4 id="十六-面向对象有哪些特性以及你对这些特性的理解"><a href="#十六-面向对象有哪些特性以及你对这些特性的理解" class="headerlink" title="十六.面向对象有哪些特性以及你对这些特性的理解?"></a>十六.面向对象有哪些特性以及你对这些特性的理解?</h4><p>​    1.继承:是从已有类得到继承信息创建新类的过程<br>​    2.封装:封装就是隐藏一切可隐藏的东西，只向外界提供最简单的编程接口。<br>​    3.多态:多态性是指允许不同子类型的对象对同一消息作出不同的响应。<br>​    4.抽象:抽象：抽象是将一类对象的共同特征总结出来构造类的过程</p><h4 id="十七-抽象类-abstract-class-和接口-interface-有什么异同"><a href="#十七-抽象类-abstract-class-和接口-interface-有什么异同" class="headerlink" title="十七.抽象类(abstract class)和接口(interface)有什么异同?"></a>十七.抽象类(abstract class)和接口(interface)有什么异同?</h4><p>相同：<br>    1.不能够实例化<br>    2.可以将抽象类和接口类型作为引用类型<br>    3.一个类如果继承了某个抽象类或者实现了某个接口都需要对其中的抽象方法全部进行实现，否则该类仍然需要被声明为抽象类<br>不同点:<br>  1.抽象类中可以定义构造器,接口中不能定义构造器<br>  2.抽象类可以有抽象方法和具体方法,接口中方法全部都是抽象方法<br>  3.接口中的成员全都是 public 的,抽象类中的成员可以是 private、默认、protected、public<br>  4.抽象类中可以定义成员变量,接口中定义的成员变量实际上都是常量<br>  5.有抽象方法的类必须被声明为抽象类，而抽象类未必要有抽象方法<br>  6.抽象类中可以包含静态方法,接口中不能有静态方法<br>  7.一个类可以实现多个接口,一个类只能继承一个抽象类接口：</p><h4 id="十八-阐述静态变量和实例变量的区别"><a href="#十八-阐述静态变量和实例变量的区别" class="headerlink" title="十八.阐述静态变量和实例变量的区别?"></a>十八.阐述静态变量和实例变量的区别?</h4><p>​    实例变量必须创建对象后通过这个对象来使用，静态变量可以直接使用类名来引用。</p><h4 id="十九-谈谈你对-Spring-的理解"><a href="#十九-谈谈你对-Spring-的理解" class="headerlink" title="十九.谈谈你对 Spring 的理解?"></a>十九.谈谈你对 Spring 的理解?</h4><p>​    Spring是一个开源框架,为简化企业级应用开发而生。Spring可以是使简单的JavaBean实现以前只有EJB才能实现的功能。<br>​    Spring 是一个IOC和AOP容器框架。<br>   Spring 容器的主要核心是:<br>       1.控制反转(IOC),传统的java开发模式中,当需要一个对象时,我们会自己使用new或者getInstance等直接或者间接调用构造方法创建一个对象。而在spring开发模式中，spring容器使用了工厂模式为我们创建了所需要的对象,不需要我们自己创建了,直接调用 spring提供的对象就可以了,这是控制反转的思想。<br>​    2.依赖注入(DI)spring使用javaBean对象的set方法或者带参数的构造方法为我们在创建所需对象时将其属性自动设置所需要的值的过程，就是依赖注入的思想。<br>​    3.面向切面编程(AOP)在面向对象编程(oop)思想中,我们将事物纵向抽成一个个的对象。而在面向切面编程中，我们将一个个的对象某些类似的方面横向抽成一个切面,对这个切面进行一些如权限控制、事物管理,记录日志等公用操作处理的过程就是面向切面编程的思想。AOP底层是动态代理,如果是接口采用JDK动态代理,如果是类采用CGLIB方式实现动态代理。</p><h4 id="二十-Spring-的常用注解"><a href="#二十-Spring-的常用注解" class="headerlink" title="二十.Spring 的常用注解?"></a>二十.Spring 的常用注解?</h4><p>​    Spring在2.5版本以后开始支持注解的方式来配置依赖注入。可以用注解的方式来代替xml中bean的描述。注解注入将会被容器在XML 注入之前被处理,所以后者会覆盖掉前者对于同一个属性的处理结果。<br>​    注解装配在spring中默认是关闭的。所以需要在spring的核心配置文件中配置一下才能使用基于注解的装配模式。配置方式如下：<br>​    &lt;context:annotation-config /&gt;<br>​    常用的注解：<br>​    @Required:该注解应用于设值方法<br>​    @Autowired：该注解应用于有值设值方法、非设值方法、构造方法和变量。<br>​    @Qualifier：该注解和@Autowired 搭配使用，用于消除特定bean自动装配的歧义。</p><h4 id="二十一-简单介绍一下-Spring-bean-的生命周期"><a href="#二十一-简单介绍一下-Spring-bean-的生命周期" class="headerlink" title="二十一.简单介绍一下 Spring bean 的生命周期?"></a>二十一.简单介绍一下 Spring bean 的生命周期?</h4><p>​    bean定义：在配置文件里面用&lt; bean &gt;&lt; /bean &gt;来进行定义。<br>​    bean初始化：有两种方式初始化:<br>​    1.在配置文件中通过指定 init-method 属性来完成<br>​    2.实现 org.springframwork.beans.factory.InitializingBean 接口<br>​    bean 调用：有三种方式可以得到 bean 实例，并进行调用<br>​    bean 销毁：销毁有两种方式<br>​    1.使用配置文件指定的 destroy-method 属性<br>​    2.实现 org.springframwork.bean.factory.DisposeableBean </p><h4 id="二十二-前台有多个参数-这些参数都是一个对象-快速得到这个对象"><a href="#二十二-前台有多个参数-这些参数都是一个对象-快速得到这个对象" class="headerlink" title="二十二.前台有多个参数,这些参数都是一个对象,快速得到这个对象?"></a>二十二.前台有多个参数,这些参数都是一个对象,快速得到这个对象?</h4><p>​    方法:直接在方法中声明这个对象,springMVC就自动把属性赋值到这个对象里</p><h4 id="二十三-springMVC和Ajax直接的相互调用"><a href="#二十三-springMVC和Ajax直接的相互调用" class="headerlink" title="二十三.springMVC和Ajax直接的相互调用?"></a>二十三.springMVC和Ajax直接的相互调用?</h4><p>​    通过jockSon框架把java里面对象转换成js可识别的json对象:<br>​    1.加入jockSon.jar<br>​    2.在配置文件中配置json的映射<br>​    3.在接受Ajax方法里面直接返回object,list等 方法前面加上注解@ResponseBody</p><h4 id="二十四-什么是springMVC-简单介绍对springMVC的理解"><a href="#二十四-什么是springMVC-简单介绍对springMVC的理解" class="headerlink" title="二十四.什么是springMVC?简单介绍对springMVC的理解?"></a>二十四.什么是springMVC?简单介绍对springMVC的理解?</h4><p>​    springMVC是一个基于java实现了MVC设计模式的请求驱动类型的轻量级的Web框架,通过把Model,View,Controller分离,<br>​    将web层进行职责解耦,把复杂的web应用分成逻辑清晰的几部分,简化开发,减少出错,方便组内开发人员直接的配合</p><h4 id="二十五-SpringMVC怎么样设定重定向和转发"><a href="#二十五-SpringMVC怎么样设定重定向和转发" class="headerlink" title="二十五.SpringMVC怎么样设定重定向和转发?"></a>二十五.SpringMVC怎么样设定重定向和转发?</h4><p>​    1.转发返回值前面加”forward:”<br>​    2.重定向返回值前面加”redirect:”</p><h4 id="二十六-SpringMVC-常用注解都有哪些？"><a href="#二十六-SpringMVC-常用注解都有哪些？" class="headerlink" title="二十六.SpringMVC 常用注解都有哪些？"></a>二十六.SpringMVC 常用注解都有哪些？</h4><p> @requestMapping 用于请求 url 映射。<br> @RequestBody 注解实现接收 http 请求的 json 数据，将 json 数据转换为 java 对象。<br> @ResponseBody 注解实现将 controller 方法返回对象转化为 json 响应给客户。</p><h4 id="二十七-如何开启注解处理器和适配器？"><a href="#二十七-如何开启注解处理器和适配器？" class="headerlink" title="二十七.如何开启注解处理器和适配器？"></a>二十七.如何开启注解处理器和适配器？</h4><p> 我们在项目中一般会在 springmvc.xml 中通过开启  <a href="mvc:annotation-driven" target="_blank" rel="noopener">mvc:annotation-driven</a>来实现注解处理器和适配器的开启。</p><h4 id="二十八-如何解决-get-和-post-乱码问题？"><a href="#二十八-如何解决-get-和-post-乱码问题？" class="headerlink" title="二十八.如何解决 get 和 post 乱码问题？"></a>二十八.如何解决 get 和 post 乱码问题？</h4><p> 解决 post 请求乱码:我们可以在 web.xml 里边配置一个 CharacterEncodingFilter 过滤器。 设置为 utf-8.<br>解决 get 请求的乱码:有两种方法。对于 get 请求中文参数出现乱码解决方法有两个:<br> 1.修改 tomcat 配置文件添加编码与工程编码一致。<br> 2.另 外 一 种 方 法 对 参 数 进 行 重 新 编 码 String userName = New<br>String(Request.getParameter(“userName”).getBytes(“ISO8859-1”), “utf-8”);</p><h4 id="二十九-display-none和visibility-hidden的区别？"><a href="#二十九-display-none和visibility-hidden的区别？" class="headerlink" title="二十九.display:none和visibility:hidden的区别？"></a>二十九.display:none和visibility:hidden的区别？</h4><p>  display:none：隐藏对应的元素，在文档布局中不再给它分配空间，它各边的元素会合拢，就当他从来不存在</p><p>  visibility:hidden 隐藏对应的元素，但是在文档布局仍保留原来的空间</p><h4 id="三十-CSS中link和-import的区别是？"><a href="#三十-CSS中link和-import的区别是？" class="headerlink" title="三十.CSS中link和@import的区别是？"></a>三十.CSS中link和@import的区别是？</h4><p>   1.link属于HTML标签,@import是CSS提供的</p><p> 2.页面被加载时,link会被加载,而@import是页面加载完再加载</p><p>  3.@import只在IE5以上才识别,link是HTML标签,无兼容问题</p><p> 4.link方式的样式的权重高于@import的权重</p><h4 id="三十一-谈谈对响应式布局的看法"><a href="#三十一-谈谈对响应式布局的看法" class="headerlink" title="三十一.谈谈对响应式布局的看法"></a>三十一.谈谈对响应式布局的看法</h4><p>  响应式布局有优点也有缺点<br>  优点:面对不同分辨率设备，灵活性强，<br>能够快捷的解决设备显示适应问题<br>  缺点:兼容各种设备时所需工作量大,效率低,代码累赘,<br>会隐藏无用的元素,加载时间长,其实这是一种折中的十设计解决方案,</p><p> 由于多方面元素影响而达不到最佳效果,在一定程度上改变了网站原有的布局结构,会出现用户混淆的情况</p><h4 id="三十二、-清除浮动的方式"><a href="#三十二、-清除浮动的方式" class="headerlink" title="三十二、  清除浮动的方式"></a>三十二、  清除浮动的方式</h4><p>1.父级div定义height<br>2.最后一个浮动元素后加空div标签 并添加样式clear:both<br>3.包含浮动元素的父标签添加样式overflow为hidden或auto<br>4.父级div定义zoom</p><h4 id="三十三、什么是Bootstrap？以及为什么要使用Bootstrap？"><a href="#三十三、什么是Bootstrap？以及为什么要使用Bootstrap？" class="headerlink" title="三十三、什么是Bootstrap？以及为什么要使用Bootstrap？"></a>三十三、什么是Bootstrap？以及为什么要使用Bootstrap？</h4><p>Bootstrap 是一个用于快速开发 Web 应用程序和网站的前端框架。Bootstrap 是基于 HTML、CSS、JAVASCRIPT 的。<br>Bootstrap具有移动设备优先、浏览器支持良好、容易上手、响应式设计等优点，所以Bootstrap被广泛应用。  </p><h4 id="三十四、使用Bootstrap创建垂直表单的基本步骤？"><a href="#三十四、使用Bootstrap创建垂直表单的基本步骤？" class="headerlink" title="三十四、使用Bootstrap创建垂直表单的基本步骤？"></a>三十四、使用Bootstrap创建垂直表单的基本步骤？</h4><p>（1）向父form元素添加role=”form”；（2）把标签和控件放在一个带有class=”form-group”的div中，这是获取最佳间距所必需的；（3）向所有的文本元素input、textarea、select添加class=”form-control”</p><h4 id="三十五-Bootstrap有哪些关于的class？"><a href="#三十五-Bootstrap有哪些关于的class？" class="headerlink" title="三十五.Bootstrap有哪些关于的class？"></a>三十五.Bootstrap有哪些关于<img class="lazyload">的class？</h4><p>（1）.img-rounded 为图片添加圆角<br>（2）.img-circle 将图片变为圆形<br>（3）.img-thumbnail 缩略图功能<br>（4）.img-responsive 图片响应式 (将很好地扩展到父元素)</p><h4 id="三十六-行内元素有哪些？块级元素有哪些？css的盒模型？"><a href="#三十六-行内元素有哪些？块级元素有哪些？css的盒模型？" class="headerlink" title="三十六.行内元素有哪些？块级元素有哪些？css的盒模型？"></a>三十六.行内元素有哪些？块级元素有哪些？css的盒模型？</h4><p>块级元素：div ,p,h1,form,ul,li<br>行内元素：span,a,label,input,img,strong,em;<br>css盒模型：内容，border,margin,padding;</p><h4 id="三十七、标签上title与alt属性的区别是什么？"><a href="#三十七、标签上title与alt属性的区别是什么？" class="headerlink" title="三十七、标签上title与alt属性的区别是什么？"></a>三十七、标签上title与alt属性的区别是什么？</h4><p>Alt当图片不显示时，用文字代表<br>Title为该属性提供信息</p><h4 id="三十八-分别写出以下几个HTML标签：文字加粗、下标、居中、字体"><a href="#三十八-分别写出以下几个HTML标签：文字加粗、下标、居中、字体" class="headerlink" title="三十八.分别写出以下几个HTML标签：文字加粗、下标、居中、字体"></a>三十八.分别写出以下几个HTML标签：文字加粗、下标、居中、字体</h4><p> 加粗：b、strong<br> 下标：sub<br> 居中：center<br> 字体：font、basefont</p><h4 id="三十九-data-属性的作用是什么？"><a href="#三十九-data-属性的作用是什么？" class="headerlink" title="三十九.data-属性的作用是什么？"></a>三十九.data-属性的作用是什么？</h4><p>　　　data-是HTML5为前端开发者提供自定义的属性，这些属性集可以通过对象的dataset属性获取，不支持该属性的浏览器可以通过 getAttribute方法获取。</p><h4 id="四十-描述z-index和叠加上下文是如何形成的。"><a href="#四十-描述z-index和叠加上下文是如何形成的。" class="headerlink" title="四十.描述z-index和叠加上下文是如何形成的。"></a>四十.描述z-index和叠加上下文是如何形成的。</h4><p> 　　z-index就是控制元素在页面的中的叠加顺序，z-index值高的元素显示在z-index值低的前面<br>z-index的使用条件：只对有 position 属性的且值不为static的元素才有效。叠加上下文和“堆栈上下文”有关，一组具有共同双亲的元素，按照堆栈顺序一起向前或向后移动构成了所谓的堆栈上下文。</p><h4 id="四十一-HTML与XHTML——二者有什么区别"><a href="#四十一-HTML与XHTML——二者有什么区别" class="headerlink" title="四十一. HTML与XHTML——二者有什么区别"></a>四十一. HTML与XHTML——二者有什么区别</h4><p> XHTML 元素必须被正确地嵌套。<br>  XHTML 元素必须被关闭。<br>    标签名必须用小写字母。<br> XHTML 文档必须拥有根元素。</p><h4 id="四十二-Bootstrap中的导航都有哪些？"><a href="#四十二-Bootstrap中的导航都有哪些？" class="headerlink" title="四十二.Bootstrap中的导航都有哪些？"></a>四十二.Bootstrap中的导航都有哪些？</h4><p> （1）导航元素：有class=”nav nav-tabs”的标签页导航，还有class=”nav nav-pills”的胶囊式标签页导航；<br> （2）导航栏：class=”navbar navbar-default” role=”navigation”；<br> （3）面包屑导航：class=”breadcrumb”</p>]]></content>
      
      
      <categories>
          
          <category> 面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> -面试题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>配置便捷属性快捷键</title>
      <link href="/2019/07/22/%E9%85%8D%E7%BD%AE%E4%BE%BF%E6%8D%B7%E5%B1%9E%E6%80%A7%E5%BF%AB%E6%8D%B7%E9%94%AE/"/>
      <url>/2019/07/22/%E9%85%8D%E7%BD%AE%E4%BE%BF%E6%8D%B7%E5%B1%9E%E6%80%A7%E5%BF%AB%E6%8D%B7%E9%94%AE/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>今天写属性时比较烦躁，想到能不能快捷一点生成属性，询问了一位前辈知道一个自定义属性<del>~</del> 直接上</p><p>首先在idea中找到Settings,在其中搜索Templates</p><p><img src="http://zai1999.club/img/xiuImg/tian1.png" alt data-src="http://zai1999.club/img/xiuImg/tian1.png" class="lazyload"><br><strong>添加时要注意先添加第二个，这里我添加名字是–定义属性</strong><br><img src="http://zai1999.club/img/xiuImg/tian3.png" alt data-src="http://zai1999.club/img/xiuImg/tian3.png" class="lazyload"></p><p>接下来就可以去尝试一下了<del>速度！就这样</del>ojbk</p>]]></content>
      
      
      <categories>
          
          <category> IDEA配置 </category>
          
          <category> 快捷键 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> -日常小调试 -IDEA自定义快捷键 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于IDEA2019版本搜索不到插件</title>
      <link href="/2019/07/22/%E5%85%B3%E4%BA%8EIDEA2019%E7%89%88%E6%9C%AC%E6%90%9C%E7%B4%A2%E4%B8%8D%E5%88%B0%E6%8F%92%E4%BB%B6/"/>
      <url>/2019/07/22/%E5%85%B3%E4%BA%8EIDEA2019%E7%89%88%E6%9C%AC%E6%90%9C%E7%B4%A2%E4%B8%8D%E5%88%B0%E6%8F%92%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><strong>今天刚刚安装了新版IDEA，因项目需要插件，结果在Marketplace中搜不到任何插件</strong></p><p><img src="http://zai1999.club/img/bugsImg/bug1.png" alt="在这里插入图片描述" data-src="http://zai1999.club/img/bugsImg/bug1.png" class="lazyload"><br><strong>也因此在网上百度查找了很多解决方法，如下idea设置：</strong><br><img src="http://zai1999.club/img/bugsImg/bug2.png" alt="在这里插入图片描述" data-src="http://zai1999.club/img/bugsImg/bug2.png" class="lazyload"><br><img src="http://zai1999.club/img/bugsImg/bug3.png" alt="在这里插入图片描述" data-src="http://zai1999.club/img/bugsImg/bug3.png" class="lazyload"><br>按照上面的方法试了之后都不行了的话，可能需要卸载重装亦或者在<a href="http://www.jetbrains.com/" target="_blank" rel="noopener">官网</a>下载插件导入</p><p>参考至<a href="https://blog.csdn.net/qq_38225558/article/details/88351753" target="_blank" rel="noopener">这里</a></p>]]></content>
      
      
      <categories>
          
          <category> IDEA配置 </category>
          
          <category> 插件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> -日常小调试 -IDEA插件 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>对于HEXO介绍</title>
      <link href="/2019/07/21/%E5%AF%B9%E4%BA%8EHEXO%E4%BB%8B%E7%BB%8D/"/>
      <url>/2019/07/21/%E5%AF%B9%E4%BA%8EHEXO%E4%BB%8B%E7%BB%8D/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>本文参考来自<a href="https://hexo.io/zh-cn/docs/" target="_blank" rel="noopener">文档Hexo</a></p><h2 id="什么是-Hexo？"><a href="#什么是-Hexo？" class="headerlink" title="什么是 Hexo？"></a>什么是 Hexo？</h2><p>Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 <a href="http://daringfireball.net/projects/markdown/" target="_blank" rel="noopener">Markdown</a>（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。</p><h3 id="安装前提"><a href="#安装前提" class="headerlink" title="安装前提"></a>安装前提</h3><p>安装 Hexo 相当简单。然而在安装前，您必须检查电脑中是否已安装下列应用程序：</p><ul><li><a href="http://nodejs.org/" target="_blank" rel="noopener">Node.js</a> (Should be at least nodejs 6.9)</li><li><a href="http://git-scm.com/" target="_blank" rel="noopener">Git</a></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install -g hexo-cli</span><br></pre></td></tr></table></figure><h3 id="安装-Git"><a href="#安装-Git" class="headerlink" title="安装 Git"></a>安装 Git</h3><ul><li><p>Windows：下载并安装 <a href="https://git-scm.com/download/win" target="_blank" rel="noopener">git</a>.</p></li><li><p>Mac：使用 <a href="http://mxcl.github.com/homebrew/" target="_blank" rel="noopener">Homebrew</a>, <a href="http://www.macports.org/" target="_blank" rel="noopener">MacPorts</a> ：<code>brew install git</code>;或下载 <a href="http://sourceforge.net/projects/git-osx-installer/" target="_blank" rel="noopener">安装程序</a> 安装。</p></li><li><p>Linux (Ubuntu, Debian)：<code>sudo apt-get install git-core</code></p></li><li></li><li><p>Linux (Fedora, Red Hat, CentOS)：<code>sudo yum install git-core</code></p></li></ul><p><strong>Windows 用户</strong></p><p>由于众所周知的原因，从上面的链接下载git for windows最好挂上一个代理，否则下载速度十分缓慢。也可以参考<a href="https://github.com/waylau/git-for-win" target="_blank" rel="noopener">这个页面</a>，收录了存储于百度云的下载地址。</p><h3 id="安装-Node-js"><a href="#安装-Node-js" class="headerlink" title="安装 Node.js"></a>安装 Node.js</h3><p>安装 Node.js 的最佳方式是使用 <a href="https://github.com/creationix/nvm" target="_blank" rel="noopener">nvm</a>。</p><p>cURL:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ curl https://raw.github.com/creationix/nvm/v0.33.11/install.sh | sh</span><br></pre></td></tr></table></figure><p>Wget:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ wget -qO- https://raw.github.com/creationix/nvm/v0.33.11/install.sh | sh</span><br></pre></td></tr></table></figure><p>安装完成后，重启终端并执行下列命令即可安装 Node.js。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ nvm install stable</span><br></pre></td></tr></table></figure><p>或者您也可以下载 <a href="http://nodejs.org/" target="_blank" rel="noopener">安装程序</a> 来安装。</p><h3 id="安装-Hexo"><a href="#安装-Hexo" class="headerlink" title="安装 Hexo"></a>安装 Hexo</h3><p>所有必备的应用程序安装完成后，即可使用 npm 安装 Hexo。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install -g hexo-cli</span><br></pre></td></tr></table></figure><p>安装后在这里需要建一个文件夹，来存放hexo所需要的文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ hexo init &lt;文件夹&gt; //新建</span><br><span class="line">$ cd &lt;文件夹&gt;//打开此文件夹</span><br><span class="line">$ npm install</span><br></pre></td></tr></table></figure><h3 id="config-yml"><a href="#config-yml" class="headerlink" title="_config.yml"></a>_config.yml</h3><p>网站的 <a href="https://hexo.io/zh-cn/docs/configuration" target="_blank" rel="noopener">配置</a> 信息，您可以在此配置大部分的参数。</p><h3 id="source"><a href="#source" class="headerlink" title="source"></a>source</h3><p>资源文件夹是存放用户资源的地方。除 <code>_posts</code> 文件夹之外，开头命名为 <code>_</code> (下划线)的文件 / 文件夹和隐藏的文件将会被忽略。Markdown 和 HTML 文件会被解析并放到 <code>public</code> 文件夹，而其他文件会被拷贝过去。</p><h3 id="themes"><a href="#themes" class="headerlink" title="themes"></a>themes</h3><p><a href="https://hexo.io/zh-cn/docs/themes" target="_blank" rel="noopener">主题</a> 文件夹。Hexo 会根据主题来生成静态页面。</p><h1 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h1><p>​               </p><p>您可以在 <code>_config.yml</code> 中修改大部分的配置。</p><iframe src="https://www.youtube.com/embed/A0Enyn70jKU" frameborder="0" allowfullscreen style="border-bottom-color: rgb(68, 68, 68); border-bottom-style: none; border-bottom-width: 0px; border-image-outset: 0; border-image-repeat: stretch; border-image-slice: 100%; border-image-source: none; border-image-width: 1; border-left-color: rgb(68, 68, 68); border-left-style: none; border-left-width: 0px; border-right-color: rgb(68, 68, 68); border-right-style: none; border-right-width: 0px; border-top-color: rgb(68, 68, 68); border-top-style: none; border-top-width: 0px; box-sizing: border-box; font-family: &amp;quot;Helvetica Neue&amp;quot;,Helvetica,Arial,sans-serif; font-size: 15px; font-style: normal; font-weight: 400; margin-bottom: 15px; margin-left: 0px; margin-right: 0px; margin-top: 15px; outline-color: invert; outline-style: none; outline-width: 0px; padding-bottom: 0px; padding-left: 0px; padding-right: 0px; padding-top: 0px; vertical-align: baseline;"></iframe><h2 id="网站"><a href="#网站" class="headerlink" title="网站"></a>网站</h2><table><thead><tr><th align="left">参数</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left"><code>title</code></td><td align="left">网站标题</td></tr><tr><td align="left"><code>subtitle</code></td><td align="left">网站副标题</td></tr><tr><td align="left"><code>description</code></td><td align="left">网站描述</td></tr><tr><td align="left"><code>author</code></td><td align="left">您的名字</td></tr><tr><td align="left"><code>language</code></td><td align="left">网站使用的语言</td></tr><tr><td align="left"><code>timezone</code></td><td align="left">网站时区。Hexo 默认使用您电脑的时区。<a href="https://en.wikipedia.org/wiki/List_of_tz_database_time_zones" target="_blank" rel="noopener">时区列表</a>。比如说：<code>America/New_York</code>, <code>Japan</code>, 和 <code>UTC</code> 。</td></tr></tbody></table><p>其中，<code>description</code>主要用于SEO，告诉搜索引擎一个关于您站点的简单描述，通常建议在其中包含您网站的关键词。<code>author</code>参数用于主题显示文章的作者。</p><h2 id="网址"><a href="#网址" class="headerlink" title="网址"></a>网址</h2><table><thead><tr><th align="left">参数</th><th align="left">描述</th><th align="left">默认值</th></tr></thead><tbody><tr><td align="left"><code>url</code></td><td align="left">网址</td><td align="left"></td></tr><tr><td align="left"><code>root</code></td><td align="left">网站根目录</td><td align="left"></td></tr><tr><td align="left"><code>permalink</code></td><td align="left">文章的 <a href="https://hexo.io/zh-cn/docs/permalinks" target="_blank" rel="noopener">永久链接</a> 格式</td><td align="left"><code>:year/:month/:day/:title/</code></td></tr><tr><td align="left"><code>permalink_defaults</code></td><td align="left">永久链接中各部分的默认值</td><td align="left"></td></tr></tbody></table><blockquote><p>网站存放在子目录</p><p>如果您的网站存放在子目录中，例如 <code>http://yoursite.com/blog</code>，则请将您的 <code>url</code> 设为 <code>http://yoursite.com/blog</code> 并把 <code>root</code> 设为 <code>/blog/</code>。</p></blockquote><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><table><thead><tr><th align="left">参数</th><th align="left">描述</th><th align="left">默认值</th></tr></thead><tbody><tr><td align="left"><code>source_dir</code></td><td align="left">资源文件夹，这个文件夹用来存放内容。</td><td align="left"><code>source</code></td></tr><tr><td align="left"><code>public_dir</code></td><td align="left">公共文件夹，这个文件夹用于存放生成的站点文件。</td><td align="left"><code>public</code></td></tr><tr><td align="left"><code>tag_dir</code></td><td align="left">标签文件夹</td><td align="left"><code>tags</code></td></tr><tr><td align="left"><code>archive_dir</code></td><td align="left">归档文件夹</td><td align="left"><code>archives</code></td></tr><tr><td align="left"><code>category_dir</code></td><td align="left">分类文件夹</td><td align="left"><code>categories</code></td></tr><tr><td align="left"><code>code_dir</code></td><td align="left">Include code 文件夹</td><td align="left"><code>downloads/code</code></td></tr><tr><td align="left"><code>i18n_dir</code></td><td align="left">国际化（i18n）文件夹</td><td align="left"><code>:lang</code></td></tr><tr><td align="left"><code>skip_render</code></td><td align="left">跳过指定文件的渲染，您可使用 <a href="https://github.com/isaacs/node-glob" target="_blank" rel="noopener">glob 表达式</a>来匹配路径。</td><td align="left"></td></tr></tbody></table><h2 id="日期-时间格式"><a href="#日期-时间格式" class="headerlink" title="日期 / 时间格式"></a>日期 / 时间格式</h2><p>Hexo 使用 <a href="http://momentjs.com/" target="_blank" rel="noopener">Moment.js</a> 来解析和显示时间。</p><table><thead><tr><th align="left">参数</th><th align="left">描述</th><th align="left">默认值</th></tr></thead><tbody><tr><td align="left"><code>date_format</code></td><td align="left">日期格式</td><td align="left"><code>YYYY-MM-DD</code></td></tr><tr><td align="left"><code>time_format</code></td><td align="left">时间格式</td><td align="left"><code>H:mm:ss</code></td></tr></tbody></table><h2 id="分页"><a href="#分页" class="headerlink" title="分页"></a>分页</h2><table><thead><tr><th align="left">参数</th><th align="left">描述</th><th align="left">默认值</th></tr></thead><tbody><tr><td align="left"><code>per_page</code></td><td align="left">每页显示的文章量 (0 = 关闭分页功能)</td><td align="left"><code>10</code></td></tr><tr><td align="left"><code>pagination_dir</code></td><td align="left">分页目录</td><td align="left"><code>page</code></td></tr></tbody></table><h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><table><thead><tr><th align="left">参数</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left"><code>theme</code></td><td align="left">当前主题名称。值为<code>false</code>时禁用主题</td></tr><tr><td align="left"><code>deploy</code></td><td align="left">部署部分的设置</td></tr></tbody></table><p>其他的暂时也用不到就不列举了请<a href="https://hexo.io/zh-cn/docs/" target="_blank" rel="noopener">参考原配置</a></p><h2 id="init"><a href="#init" class="headerlink" title="init"></a>init</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo init [folder]</span><br></pre></td></tr></table></figure><p>新建一个网站。如果没有设置 <code>folder</code> ，Hexo 默认在目前的文件夹建立网站。</p><h2 id="new"><a href="#new" class="headerlink" title="new"></a>new</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new [layout] &lt;title&gt;</span><br></pre></td></tr></table></figure><p>新建一篇文章。如果没有设置 <code>layout</code> 的话，默认使用 <a href="https://hexo.io/zh-cn/docs/configuration" target="_blank" rel="noopener">_config.yml</a> 中的 <code>default_layout</code> 参数代替。如果标题包含空格的话，请使用引号括起来。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new &quot;post title with whitespace&quot;</span><br></pre></td></tr></table></figure><p> clean</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo clean</span><br></pre></td></tr></table></figure><p>清除缓存文件 (<code>db.json</code>) 和已生成的静态文件 (<code>public</code>)。</p><p>在某些情况（尤其是更换主题后），如果发现您对站点的更改无论如何也不生效，您可能需要运行该命令。</p><h2 id="generate"><a href="#generate" class="headerlink" title="generate"></a>generate</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>生成静态文件。</p><table><thead><tr><th align="left">选项</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left"><code>-d</code>, <code>--deploy</code></td><td align="left">文件生成后立即部署网站</td></tr><tr><td align="left"><code>-w</code>, <code>--watch</code></td><td align="left">监视文件变动</td></tr></tbody></table><p>该命令可以简写为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo g</span><br></pre></td></tr></table></figure><h1 id="主题"><a href="#主题" class="headerlink" title="主题"></a>主题</h1><p>​               主题的话非常简单我们只需要根据<a href="https://hexo.io/themes/" target="_blank" rel="noopener">主题</a>去下载自己钟意的主题下载到文件夹themes下，切换主题在<code>_config.yml</code> 内的 <code>theme</code> 设定，即可切换主题。</p>]]></content>
      
      
      <categories>
          
          <category> 博客 </category>
          
          <category> HEXO搭建 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 安装 </tag>
            
            <tag> HEXO安装 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于Tomcat在服务器的运行乱码问题</title>
      <link href="/2019/07/12/%E5%85%B3%E4%BA%8ETomcat%E5%9C%A8%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E8%BF%90%E8%A1%8C%E4%B9%B1%E7%A0%81%E9%97%AE%E9%A2%98/"/>
      <url>/2019/07/12/%E5%85%B3%E4%BA%8ETomcat%E5%9C%A8%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E8%BF%90%E8%A1%8C%E4%B9%B1%E7%A0%81%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>看控制台乱码的问题困扰了好久（<a href="https://www.jianshu.com/p/d23b2cbc5564" target="_blank" rel="noopener">来自简书</a>）</p><p>1、找到tomcat路径下<strong>conf/logging.properties</strong></p><p>2、找到<strong>java.util.logging.ConsoleHandler.encoding = UTF-8</strong></p><p>​      修改为<strong>java.util.logging.ConsoleHandler.encoding = GBK</strong></p><p>3、重启tomcat。</p>]]></content>
      
      
      <categories>
          
          <category> Tomcat </category>
          
          <category> 不易被发现类 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> -日常小Bug -服务器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java反射和映射(Class类)</title>
      <link href="/2019/07/10/java%E5%8F%8D%E5%B0%84-Class%E7%B1%BB/"/>
      <url>/2019/07/10/java%E5%8F%8D%E5%B0%84-Class%E7%B1%BB/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="java反射和映射"><a href="#java反射和映射" class="headerlink" title="java反射和映射"></a>java反射和映射</h1><h2 id="什么是反射？等同于映射吗？"><a href="#什么是反射？等同于映射吗？" class="headerlink" title="什么是反射？等同于映射吗？"></a>什么是反射？等同于映射吗？</h2><h3 id="完全不相关的。反射是一个机制，映射是一种关系。"><a href="#完全不相关的。反射是一个机制，映射是一种关系。" class="headerlink" title="完全不相关的。反射是一个机制，映射是一种关系。"></a>完全不相关的。反射是一个机制，映射是一种关系。</h3><p>+++</p><h2 id="一、什么是反射？"><a href="#一、什么是反射？" class="headerlink" title="一、什么是反射？"></a>一、什么是反射？</h2><p>Java反射说的是在运行状态中，对于任何一个类，我们都能够知道这个类有哪些方法和属性。对于任何一个对象，我们都能够对它的方法和属性进行调用。我们把这种动态获取对象信息和调用对象方法的功能称之为反射机制。<br><strong>反射能做什么</strong><br><em>在运行时判断任意一个对象所属的类；<br><em>在运行时构造任意一个类的对象；<br>*在运行时判断任意一个类所具有的成员变量和方法；<br>*在运行时调用任意一个对象的方法；<br>*生成动态代理。<br>*</em></em>映射（不做详细介绍）推荐一个 <a href="https://blog.csdn.net/qq_37080070/article/details/80573134" java之映射"" target="_blank" rel="noopener">映射</a>***</p><h2 id="二、反射的概述"><a href="#二、反射的概述" class="headerlink" title="二、反射的概述"></a>二、反射的概述</h2><p>JAVA反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性；这种动态获取的信息以及动态调用对象的方法的功能称为java语言的反射机制。<br>要想解剖一个类,必须先要获取到该类的字节码文件对象。而解剖使用的就是Class类中的方法.所以先要获取到每一个字节码文件对应的Class类型的对象.</p><p>反射就是把java类中的各种成分映射成一个个的Java对象<br><em>举个例子</em><br>例如：一个类有：成员变量、方法、构造方法、包等等信息，利用反射技术可以对一个类进行解剖，把个个组成部分映射成一个个对象。<br>     （其实：一个类中这些成员方法、构造方法、在加入类中都有一个类来描述）<br>如图是类的正常加载过程：反射的原理在与class对象。<br>熟悉一下加载的时候：Class对象的由来是将class文件读入内存，并为之创建一个Class对象。</p><h2 id="三、查看class类在java中的api详解（对于1-7的API）"><a href="#三、查看class类在java中的api详解（对于1-7的API）" class="headerlink" title="三、查看class类在java中的api详解（对于1.7的API）"></a>三、查看class类在java中的api详解（对于1.7的API）</h2><p>对于Class类了解<br>Class 类的实例表示正在运行的 Java 应用程序中的类和接口。也就是jvm中有N多的实例每个类都有该Class对象。（包括基本数据类型）<br>Class 没有公共构造方法。Class 对象是在加载类时由 Java 虚拟机以及通过调用类加载器中的defineClass 方法自动构造的。也就是这不需要我们自己去处理创建，JVM已经帮我们创建好了。</p><h2 id="四、反射的使用（这里使用Student类做演示）"><a href="#四、反射的使用（这里使用Student类做演示）" class="headerlink" title="四、反射的使用（这里使用Student类做演示）"></a>四、反射的使用（这里使用Student类做演示）</h2><p>先写一个Student类。</p><h2 id="1、获取Class对象的三种方式"><a href="#1、获取Class对象的三种方式" class="headerlink" title="1、获取Class对象的三种方式"></a>1、获取Class对象的三种方式</h2><h4 id="1-1-Object-——-gt-getClass"><a href="#1-1-Object-——-gt-getClass" class="headerlink" title="1.1 Object ——&gt; getClass();"></a>1.1 Object ——&gt; getClass();</h4><h4 id="1-2-任何数据类型（包括基本数据类型）都有一个“静态”的class属性"><a href="#1-2-任何数据类型（包括基本数据类型）都有一个“静态”的class属性" class="headerlink" title="1.2 任何数据类型（包括基本数据类型）都有一个“静态”的class属性"></a>1.2 任何数据类型（包括基本数据类型）都有一个“静态”的class属性</h4><h4 id="1-3-通过Class类的静态方法：forName（String-className）-常用"><a href="#1-3-通过Class类的静态方法：forName（String-className）-常用" class="headerlink" title="1.3 通过Class类的静态方法：forName（String  className）(常用)"></a>1.3 通过Class类的静态方法：forName（String  className）(常用)</h4><ul><li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">package</span> fanshe;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    - 获取Class对象的三种方式</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">    - 1 Object ——&gt; getClass();</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">    - 2 任何数据类型（包括基本数据类型）都有一个“静态”的class属性</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    - 3 通过Class类的静态方法：forName（String  className）(常用)</span></span><br><span class="line"><span class="comment">      *</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Fanshe</span> </span>&#123;</span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">          <span class="comment">//第一种方式获取Class对象  </span></span><br><span class="line">          Student stu1 = <span class="keyword">new</span> Student();<span class="comment">//这一new 产生一个Student对象，一个Class对象。</span></span><br><span class="line">          Class stuClass = stu1.getClass();<span class="comment">//获取Class对象</span></span><br><span class="line">          System.out.println(stuClass.getName());</span><br><span class="line">    </span><br><span class="line">      <span class="comment">//第二种方式获取Class对象</span></span><br><span class="line">    Class stuClass2 = Student.class;</span><br><span class="line">      System.out.println(stuClass == stuClass2);<span class="comment">//判断第一种方式获取的Class对象和第二种方式获取的是否是同一个</span></span><br><span class="line">    </span><br><span class="line">   <span class="comment">//第三种方式获取Class对象</span></span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">       Class stuClass3 = Class.forName(<span class="string">"fanshe.Student"</span>);<span class="comment">//注意此字符串必须是真实路径，就是带包名的类路径，包名.类名</span></span><br><span class="line">       System.out.println(stuClass3 == stuClass2);<span class="comment">//判断三种方式是否获取的是同一个Class对象</span></span><br><span class="line">   &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">       e.printStackTrace();</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#### 注意：在运行期间，一个类，只有一个Class对象产生。 </span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">三种方式常用第三种，第一种对象都有了还要反射干什么。第二种需要导入类的包，依赖太强，不导包就抛编译错误。一般都第三种，一个字符串可以传入也可写在配置文件中等多种方法。</span><br><span class="line"></span><br><span class="line">## 2、通过反射获取构造方法并使用：</span><br><span class="line"></span><br><span class="line"> student类：</span><br><span class="line"></span><br><span class="line">​```java</span><br><span class="line">package fanshe;</span><br><span class="line">public class Student &#123;</span><br><span class="line">//---------------构造方法-------------------</span><br><span class="line">//（默认的构造方法）</span><br><span class="line">Student(String str)&#123;</span><br><span class="line">System.out.println(&quot;(默认)的构造方法 s = &quot; + str);</span><br><span class="line">&#125;</span><br><span class="line">//无参构造方法</span><br><span class="line">public Student()&#123;</span><br><span class="line">System.out.println(&quot;调用了公有、无参构造方法执行了。。。&quot;);</span><br><span class="line">&#125;</span><br><span class="line">//有一个参数的构造方法</span><br><span class="line">public Student(char name)&#123;</span><br><span class="line">System.out.println(&quot;姓名：&quot; + name);</span><br><span class="line">&#125;</span><br><span class="line">//有多个参数的构造方法</span><br><span class="line">public Student(String name ,int age)&#123;</span><br><span class="line">System.out.println(&quot;姓名：&quot;+name+&quot;年龄：&quot;+ age);//这的执行效率有问题，以后解决。</span><br><span class="line">&#125;</span><br><span class="line">//受保护的构造方法</span><br><span class="line">protected Student(boolean n)&#123;</span><br><span class="line">System.out.println(&quot;受保护的构造方法 n = &quot; + n);</span><br><span class="line">&#125;</span><br><span class="line">//私有构造方法</span><br><span class="line">private Student(int age)&#123;</span><br><span class="line">System.out.println(&quot;私有的构造方法   年龄：&quot;+ age);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>共有6个构造方法；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> fanshe;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Constructor;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">- 通过Class对象可以获取某个类中的：构造方法、成员变量、成员方法；并访问成员；</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">- </span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">- 1.获取构造方法：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">- 1).批量的方法：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">- public Constructor[] getConstructors()：所有"公有的"构造方法</span></span><br><span class="line"><span class="comment">  public Constructor[] getDeclaredConstructors()：获取所有的构造方法(包括私有、受保护、默认、公有)</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">- 2).获取单个的方法，并调用：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">- public Constructor getConstructor(Class... parameterTypes):获取单个的"公有的"构造方法：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">- public Constructor getDeclaredConstructor(Class... parameterTypes):获取"某个构造方法"可以是私有的，或受保护、默认、公有；</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">- </span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">- 调用构造方法：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">- Constructor--&gt;newInstance(Object... initargs)</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Constructors</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">      <span class="comment">//1.加载Class对象</span></span><br><span class="line">      Class clazz = Class.forName(<span class="string">"fanshe.Student"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.获取所有公有构造方法</span></span><br><span class="line">    System.out.println(<span class="string">"**********************所有公有构造方法*********************************"</span>);</span><br><span class="line">    Constructor[] conArray = clazz.getConstructors();</span><br><span class="line">    <span class="keyword">for</span>(Constructor c : conArray)&#123;</span><br><span class="line">        System.out.println(c);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">"************所有的构造方法(包括：私有、受保护、默认、公有)***************"</span>);</span><br><span class="line">    conArray = clazz.getDeclaredConstructors();</span><br><span class="line">    <span class="keyword">for</span>(Constructor c : conArray)&#123;</span><br><span class="line">        System.out.println(c);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">"*****************获取公有、无参的构造方法*******************************"</span>);</span><br><span class="line">    Constructor con = clazz.getConstructor(<span class="keyword">null</span>);</span><br><span class="line">    <span class="comment">//1&gt;、因为是无参的构造方法所以类型是一个null,不写也可以：这里需要的是一个参数的类型，切记是类型</span></span><br><span class="line">    <span class="comment">//2&gt;、返回的是描述这个无参构造函数的类对象。</span></span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">"con = "</span> + con);</span><br><span class="line">    <span class="comment">//调用构造方法</span></span><br><span class="line">    Object obj = con.newInstance();</span><br><span class="line"><span class="comment">//  System.out.println("obj = " + obj);</span></span><br><span class="line"><span class="comment">//  Student stu = (Student)obj;</span></span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">"******************获取私有构造方法，并调用*******************************"</span>);</span><br><span class="line">    con = clazz.getDeclaredConstructor(<span class="keyword">char</span>.class);</span><br><span class="line">    System.out.println(con);</span><br><span class="line">    <span class="comment">//调用构造方法</span></span><br><span class="line">    con.setAccessible(<span class="keyword">true</span>);<span class="comment">//暴力访问(忽略掉访问修饰符)</span></span><br><span class="line">    obj = con.newInstance(<span class="string">'男'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>后台输出：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">********************所有公有构造方法*********************************</span><br><span class="line"><span class="keyword">public</span> fanshe.Student(java.lang.String,<span class="keyword">int</span>)</span><br><span class="line"><span class="keyword">public</span> fanshe.Student(<span class="keyword">char</span>)</span><br><span class="line"><span class="keyword">public</span> fanshe.Student()</span><br><span class="line">************所有的构造方法(包括：私有、受保护、默认、公有)***************</span><br><span class="line"><span class="keyword">private</span> fanshe.Student(<span class="keyword">int</span>)</span><br><span class="line"><span class="keyword">protected</span> fanshe.Student(<span class="keyword">boolean</span>)</span><br><span class="line"><span class="keyword">public</span> fanshe.Student(java.lang.String,<span class="keyword">int</span>)</span><br><span class="line"><span class="keyword">public</span> fanshe.Student(<span class="keyword">char</span>)</span><br><span class="line"><span class="keyword">public</span> fanshe.Student()</span><br><span class="line">fanshe.Student(java.lang.String)</span><br><span class="line">*****************获取公有、无参的构造方法*******************************</span><br><span class="line">con = <span class="keyword">public</span> fanshe.Student()</span><br><span class="line">调用了公有、无参构造方法执行了。。。</span><br><span class="line">******************获取私有构造方法，并调用*******************************</span><br><span class="line"><span class="keyword">public</span> fanshe.Student(<span class="keyword">char</span>)</span><br><span class="line">姓名：男</span><br></pre></td></tr></table></figure><p><strong>调用方法：</strong></p><p>1.获取构造方法：</p><p>  1).批量的方法：<br>public Constructor[] getConstructors()：所有”公有的”构造方法<br>             public Constructor[] getDeclaredConstructors()：获取所有的构造方法(包括私有、受保护、默认、公有)</p><p>   2).获取单个的方法，并调用：<br>public Constructor getConstructor(Class… parameterTypes):获取单个的”公有的”构造方法：<br>public Constructor getDeclaredConstructor(Class… parameterTypes):获取”某个构造方法”可以是私有的，或受保护、默认、公有；</p><p>   调用构造方法：</p><p>Constructor–&gt;newInstance(Object… initargs)</p><p> 2、newInstance是 Constructor类的方法（管理构造函数的类）</p><p>api的解释为：</p><p>``newInstance(Object…  initargs)<br>            使用此 <code>Constructor</code> 对象表示的构造方法来创建该构造方法的声明类的新实例，并用指定的初始化参数初始化该实例。</p><p>它的返回值是T类型，所以newInstance是创建了一个构造方法的声明类的新实例对象。并为之调用</p><h3 id="3、获取成员变量并调用"><a href="#3、获取成员变量并调用" class="headerlink" title="3、获取成员变量并调用"></a>3、获取成员变量并调用</h3><p>student类：</p><ul><li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> fanshe.field;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">()</span></span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//**********字段*************//</span></span><br><span class="line"><span class="keyword">public</span> String name;</span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">int</span> age;</span><br><span class="line"><span class="keyword">char</span> sex;</span><br><span class="line"><span class="keyword">private</span> String phoneNum;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">"Student [name="</span> + name + <span class="string">", age="</span> + age + <span class="string">", sex="</span> + sex</span><br><span class="line"></span><br><span class="line">- <span class="string">", phoneNum="</span> + phoneNum + <span class="string">"]"</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li></ul><p>测试类:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> fanshe.field;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">- 获取成员变量并调用：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">- </span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">- 1.批量的</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">- 1).Field[] getFields():获取所有的"公有字段"</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">- 2).Field[] getDeclaredFields():获取所有字段，包括：私有、受保护、默认、公有；</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">- 2.获取单个的：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">- 1).public Field getField(String fieldName):获取某个"公有的"字段；</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">- 2).public Field getDeclaredField(String fieldName):获取某个字段(可以是私有的)</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">- </span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">- 设置字段的值：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">- Field --&gt; public void set(Object obj,Object value):</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">- 参数说明：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">- 1.obj:要设置的字段所在的对象；</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">- 2.value:要为字段设置的值；</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">- */</span></span><br><span class="line">  <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Fields</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  ```</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">      <span class="comment">//1.获取Class对象</span></span><br><span class="line">      Class stuClass = Class.forName(<span class="string">"fanshe.field.Student"</span>);</span><br><span class="line">      <span class="comment">//2.获取字段</span></span><br><span class="line">      System.out.println(<span class="string">"************获取所有公有的字段********************"</span>);</span><br><span class="line">      Field[] fieldArray = stuClass.getFields();</span><br><span class="line">      <span class="keyword">for</span>(Field f : fieldArray)&#123;</span><br><span class="line">          System.out.println(f);</span><br><span class="line">      &#125;</span><br><span class="line">      System.out.println(<span class="string">"************获取所有的字段(包括私有、受保护、默认的)********************"</span>);</span><br><span class="line">      fieldArray = stuClass.getDeclaredFields();</span><br><span class="line">      <span class="keyword">for</span>(Field f : fieldArray)&#123;</span><br><span class="line">          System.out.println(f);</span><br><span class="line">      &#125;</span><br><span class="line">      System.out.println(<span class="string">"*************获取公有字段**并调用***********************************"</span>);</span><br><span class="line">      Field f = stuClass.getField(<span class="string">"name"</span>);</span><br><span class="line">      System.out.println(f);</span><br><span class="line">      <span class="comment">//获取一个对象</span></span><br><span class="line">      Object obj = stuClass.getConstructor().newInstance();<span class="comment">//产生Student对象--》Student stu = new Student();</span></span><br><span class="line">      <span class="comment">//为字段设置值</span></span><br><span class="line">      f.set(obj, <span class="string">"刘德华"</span>);<span class="comment">//为Student对象中的name属性赋值--》stu.name = "刘德华"</span></span><br><span class="line">      <span class="comment">//验证</span></span><br><span class="line">      Student stu = (Student)obj;</span><br><span class="line">      System.out.println(<span class="string">"验证姓名："</span> + stu.name);</span><br><span class="line"> </span><br><span class="line">        System.out.println(<span class="string">"**************获取私有字段****并调用********************************"</span>);</span><br><span class="line">        f = stuClass.getDeclaredField(<span class="string">"phoneNum"</span>);</span><br><span class="line">        System.out.println(f);</span><br><span class="line">        f.setAccessible(<span class="keyword">true</span>);<span class="comment">//暴力反射，解除私有限定</span></span><br><span class="line">        f.set(obj, <span class="string">"18888889999"</span>);</span><br><span class="line">        System.out.println(<span class="string">"验证电话："</span> + stu);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>后台输出：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">************获取所有公有的字段********************</span><br><span class="line"><span class="keyword">public</span> java.lang.String fanshe.field.Student.name</span><br><span class="line">************获取所有的字段(包括私有、受保护、默认的)********************</span><br><span class="line"><span class="keyword">public</span> java.lang.String fanshe.field.Student.name</span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">int</span> fanshe.field.Student.age</span><br><span class="line"><span class="keyword">char</span> fanshe.field.Student.sex</span><br><span class="line"><span class="keyword">private</span> java.lang.String fanshe.field.Student.phoneNum</span><br><span class="line">*************获取公有字段**并调用***********************************</span><br><span class="line"><span class="keyword">public</span> java.lang.String fanshe.field.Student.name</span><br><span class="line">验证姓名：刘德华</span><br><span class="line">**************获取私有字段****并调用********************************</span><br><span class="line"><span class="keyword">private</span> java.lang.String fanshe.field.Student.phoneNum</span><br><span class="line">验证电话：Student [name=刘德华, age=<span class="number">0</span>, sex=</span><br></pre></td></tr></table></figure><p>由此可见</p><p>调用字段时：需要传递两个参数：</p><p>Object obj = stuClass.getConstructor().newInstance();//产生Student对象–》Student stu = new Student();<br>//为字段设置值<br>f.set(obj, “刘德华”);//为Student对象中的name属性赋值–》stu.name = “刘德华”</p><p>第一个参数：要传入设置的对象，第二个参数：要传入实参</p><p>也可以反射Main方法</p><p>（在此不做详解）</p><p><strong>4、获取成员方法并调用</strong></p><p>student类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> fanshe.method;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line">    <span class="comment">//**************成员方法***************//</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show1</span><span class="params">(String s)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"调用了：公有的，String参数的show1(): s = "</span> + s);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">show2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"调用了：受保护的，无参的show2()"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">show3</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"调用了：默认的，无参的show3()"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">show4</span><span class="params">(<span class="keyword">int</span> age)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"调用了，私有的，并且有返回值的，int参数的show4(): age = "</span> + age);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"abcd"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> fanshe.method;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 获取成员方法并调用：</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 1.批量的：</span></span><br><span class="line"><span class="comment"> *      public Method[] getMethods():获取所有"公有方法"；（包含了父类的方法也包含Object类）</span></span><br><span class="line"><span class="comment"> *      public Method[] getDeclaredMethods():获取所有的成员方法，包括私有的(不包括继承的)</span></span><br><span class="line"><span class="comment"> * 2.获取单个的：</span></span><br><span class="line"><span class="comment"> *      public Method getMethod(String name,Class&lt;?&gt;... parameterTypes):</span></span><br><span class="line"><span class="comment"> *                  参数：</span></span><br><span class="line"><span class="comment"> *                      name : 方法名；</span></span><br><span class="line"><span class="comment"> *                      Class ... : 形参的Class类型对象</span></span><br><span class="line"><span class="comment"> *      public Method getDeclaredMethod(String name,Class&lt;?&gt;... parameterTypes)</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> *   调用方法：</span></span><br><span class="line"><span class="comment"> *      Method --&gt; public Object invoke(Object obj,Object... args):</span></span><br><span class="line"><span class="comment"> *                  参数说明：</span></span><br><span class="line"><span class="comment"> *                  obj : 要调用方法的对象；</span></span><br><span class="line"><span class="comment"> *                  args:调用方式时所传递的实参；</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">):</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MethodClass</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//1.获取Class对象</span></span><br><span class="line">        Class stuClass = Class.forName(<span class="string">"fanshe.method.Student"</span>);</span><br><span class="line">        <span class="comment">//2.获取所有公有方法</span></span><br><span class="line">        System.out.println(<span class="string">"***************获取所有的”公有“方法*******************"</span>);</span><br><span class="line">        stuClass.getMethods();</span><br><span class="line">        Method[] methodArray = stuClass.getMethods();</span><br><span class="line">        <span class="keyword">for</span>(Method m : methodArray)&#123;</span><br><span class="line">            System.out.println(m);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"***************获取所有的方法，包括私有的*******************"</span>);</span><br><span class="line">        methodArray = stuClass.getDeclaredMethods();</span><br><span class="line">        <span class="keyword">for</span>(Method m : methodArray)&#123;</span><br><span class="line">            System.out.println(m);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"***************获取公有的show1()方法*******************"</span>);</span><br><span class="line">        Method m = stuClass.getMethod(<span class="string">"show1"</span>, String.class);</span><br><span class="line">        System.out.println(m);</span><br><span class="line">        <span class="comment">//实例化一个Student对象</span></span><br><span class="line">        Object obj = stuClass.getConstructor().newInstance();</span><br><span class="line">        m.invoke(obj, <span class="string">"刘德华"</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"***************获取私有的show4()方法******************"</span>);</span><br><span class="line">        m = stuClass.getDeclaredMethod(<span class="string">"show4"</span>, <span class="keyword">int</span>.class);</span><br><span class="line">        System.out.println(m);</span><br><span class="line">        m.setAccessible(<span class="keyword">true</span>);<span class="comment">//解除私有限定</span></span><br><span class="line">        Object result = m.invoke(obj, <span class="number">20</span>);<span class="comment">//需要两个参数，一个是要调用的对象（获取有反射），一个是实参</span></span><br><span class="line">        System.out.println(<span class="string">"返回值："</span> + result);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>控制台值：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">***************获取所有的”公有“方法*******************</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> fanshe.method.Student.show1(java.lang.String)</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> java.lang.Object.wait(<span class="keyword">long</span>,<span class="keyword">int</span>) <span class="keyword">throws</span> java.lang.InterruptedException</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> java.lang.Object.wait(<span class="keyword">long</span>) <span class="keyword">throws</span> java.lang.InterruptedException</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> java.lang.Object.wait() <span class="keyword">throws</span> java.lang.InterruptedException</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">boolean</span> java.lang.Object.equals(java.lang.Object)</span><br><span class="line"><span class="keyword">public</span> java.lang.String java.lang.Object.toString()</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">int</span> java.lang.Object.hashCode()</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> java.lang.Class java.lang.Object.getClass()</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> java.lang.Object.notify()</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> java.lang.Object.notifyAll()</span><br><span class="line">***************获取所有的方法，包括私有的*******************</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> fanshe.method.Student.show1(java.lang.String)</span><br><span class="line"><span class="keyword">private</span> java.lang.String fanshe.method.Student.show4(<span class="keyword">int</span>)</span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> fanshe.method.Student.show2()</span><br><span class="line"><span class="keyword">void</span> fanshe.method.Student.show3()</span><br><span class="line">***************获取公有的show1()方法*******************</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> fanshe.method.Student.show1(java.lang.String)</span><br><span class="line">调用了：公有的，String参数的show1(): s = 刘德华</span><br><span class="line">***************获取私有的show4()方法******************</span><br><span class="line"><span class="keyword">private</span> java.lang.String fanshe.method.Student.show4(<span class="keyword">int</span>)</span><br><span class="line">调用了，私有的，并且有返回值的，<span class="keyword">int</span>参数的show4(): age = <span class="number">20</span></span><br><span class="line">返回值：abcd</span><br></pre></td></tr></table></figure><p><strong>5、反射方法的其它使用之—通过反射运行配置文件内容</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"is show()"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>配置文件以txt文件为例子（pro.txt）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">className = cn.fanshe.Student</span><br><span class="line">methodName = show</span><br></pre></td></tr></table></figure><p>测试类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.FileNotFoundException;</span><br><span class="line"><span class="keyword">import</span> java.io.FileReader;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.util.Properties;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 我们利用反射和配置文件，可以使：应用程序更新时，对源码无需进行任何修改</span></span><br><span class="line"><span class="comment"> * 我们只需要将新类发送给客户端，并修改配置文件即可</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//通过反射获取Class对象</span></span><br><span class="line">        Class stuClass = Class.forName(getValue(<span class="string">"className"</span>));<span class="comment">//"cn.fanshe.Student"</span></span><br><span class="line">        <span class="comment">//2获取show()方法</span></span><br><span class="line">        Method m = stuClass.getMethod(getValue(<span class="string">"methodName"</span>));<span class="comment">//show</span></span><br><span class="line">        <span class="comment">//3.调用show()方法</span></span><br><span class="line">        m.invoke(stuClass.getConstructor().newInstance());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//此方法接收一个key，在配置文件中获取相应的value</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getValue</span><span class="params">(String key)</span> <span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line">        Properties pro = <span class="keyword">new</span> Properties();<span class="comment">//获取配置文件的对象</span></span><br><span class="line">        FileReader in = <span class="keyword">new</span> FileReader(<span class="string">"pro.txt"</span>);<span class="comment">//获取输入流</span></span><br><span class="line">        pro.load(in);<span class="comment">//将流加载到配置文件对象中</span></span><br><span class="line">        in.close();</span><br><span class="line">        <span class="keyword">return</span> pro.getProperty(key);<span class="comment">//返回根据key获取的value值</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>6、反射方法的其它使用之—通过反射越过泛型检查</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 通过反射越过泛型检查</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 例如：有一个String泛型的集合，怎样能向这个集合中添加一个Integer类型的值？</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        ArrayList&lt;String&gt; strList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        strList.add(<span class="string">"aaa"</span>);</span><br><span class="line">        strList.add(<span class="string">"bbb"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  strList.add(100);</span></span><br><span class="line">        <span class="comment">//获取ArrayList的Class对象，反向的调用add()方法，添加数据</span></span><br><span class="line">        Class listClass = strList.getClass(); <span class="comment">//得到 strList 对象的字节码 对象</span></span><br><span class="line">        <span class="comment">//获取add()方法</span></span><br><span class="line">        Method m = listClass.getMethod(<span class="string">"add"</span>, Object.class);</span><br><span class="line">        <span class="comment">//调用add()方法</span></span><br><span class="line">        m.invoke(strList, <span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//遍历集合</span></span><br><span class="line">        <span class="keyword">for</span>(Object obj : strList)&#123;</span><br><span class="line">            System.out.println(obj);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上参考为(<a href="https://blog.csdn.net/lwl20140904/article/details/80163880" target="_blank" rel="noopener">反射是框架设计的灵魂</a></p><p>)</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
          <category> 底层了解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> servlet处理 </tag>
            
            <tag> jsp接收和显示 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>jsp分页及其文件上传</title>
      <link href="/2019/06/11/jsp%E5%88%86%E9%A1%B5%E5%8F%8A%E5%85%B6%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/"/>
      <url>/2019/06/11/jsp%E5%88%86%E9%A1%B5%E5%8F%8A%E5%85%B6%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>#jsp Servlet 分页<br>分页的意义：<br>        如果查询出的数据量过大，将这些数据在一个页面全部显示的话，就会花更多的时间将这些大量数据从服务器传递到客户端，从而导致客户端页面打开速度变慢，当多个用户同时访问服务器时，每个用户都查询出大量的数据，而这些数据都必须在服务器端的内存中存放，这势必造成服务器的内存资源紧张甚至崩溃，降低服务器的运行效率 </p><pre><code>除了需要所必须的数据之外，还显示了记录的总条数、当前页码和总页数；并且图示表明每页显示4条数据，这个数值可以人为设定 </code></pre><p>###分页的关键几个步骤<br>(1)确定每页显示的数据数量<br>(2)计算显示总页数<br>(3)编写SQL语句<br>建立一个分页的实体类 (起名为Page了，省略了get、set等)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Page</span> </span>&#123;</span><br><span class="line">    Integer currPageNo = <span class="number">1</span>; <span class="comment">//当前页码</span></span><br><span class="line">    Integer pageSize;       <span class="comment">//页面大小</span></span><br><span class="line">    Integer totalCount;    <span class="comment">//记录总数</span></span><br><span class="line">    Integer totalPageCount;<span class="comment">//总页数</span></span><br><span class="line">    List&lt;News&gt; list;        <span class="comment">//每页要显示的上新闻集合</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了防止大于总页数或小于总页数（在以下做出规定）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCurrPageNo</span><span class="params">(Integer currPageNo)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (currPageNo &gt;= totalPageCount) &#123;</span><br><span class="line">           <span class="keyword">this</span>.currPageNo = totalPageCount;</span><br><span class="line">       &#125; <span class="keyword">else</span> <span class="keyword">if</span> (currPageNo &gt;= <span class="number">1</span> ) &#123;</span><br><span class="line">       <span class="keyword">this</span>.currPageNo = currPageNo;</span><br><span class="line">       &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">           <span class="keyword">this</span>.currPageNo=<span class="number">1</span>;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>记录了总数传入，并计算出总页数，防止有剩余出来的，多余之处加上一</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setTotalCount</span><span class="params">(Integer totalCount)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (totalCount &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            totalPageCount = (totalCount % pageSize == <span class="number">0</span>) ?</span><br><span class="line">                    (totalCount / pageSize) :</span><br><span class="line">                    (totalCount / pageSize + <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">this</span>.totalCount = totalCount;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>在jsp页面中注意上一页和下一页的加减首页以及末页<br>这里的末页为总页数</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[&lt;%=pageIndex%&gt;/&lt;%=page1.getTotalPageCount()%&gt;]</span><br><span class="line">     &lt;a href="/NewsServlet?pageIndex=1"&gt;首页&lt;/a&gt;</span><br><span class="line">     &lt;a href="/NewsServlet?pageIndex=&lt;%=pageIndex-1%&gt;"&gt;上一页&lt;/a&gt;</span><br><span class="line">     &lt;a href="/NewsServlet?pageIndex=&lt;%=pageIndex+1%&gt;"&gt;下一页&lt;/a&gt;</span><br><span class="line">     &lt;a href="/NewsServlet?pageIndex=&lt;%=page1.getTotalPageCount()%&gt;"&gt;末页&lt;/a&gt;</span><br></pre></td></tr></table></figure><p>Servlet的方法我就不写了（本人对某些方面懒）</p><p>#文件的上传和下载</p><h2 id="什么是服务器组件"><a href="#什么是服务器组件" class="headerlink" title="什么是服务器组件"></a>什么是服务器组件</h2><pre><code>编写控制器Servlet时，必须要继承HttpServlet类；而在创建编码过滤器时，需要实现Filter接口。 这些HttpServlet类和Filter接口都是Tomcat服务器的lib目录下的jar包中所存在的，这些由服务器提供的类或接口，称为服务器组件</code></pre><h2 id="什么是自定义组件"><a href="#什么是自定义组件" class="headerlink" title="什么是自定义组件"></a>什么是自定义组件</h2><pre><code>在项目中，我们编写了DAO持久化层连接数据库，其中包括连接工厂类、DAO接口、DAO接口实现类和封装数据的JavaBean， 这些自定义的类或接口，称为自定义组件 </code></pre><h2 id="什么是第三方组件"><a href="#什么是第三方组件" class="headerlink" title="什么是第三方组件"></a>什么是第三方组件</h2><pre><code>    有时候一个项目中的某些功能既不能使用服务器组件来实现，也无法或不容易使用自定义组件来实现， 此时就需要借助第三方组织或个人编写的、用于实现特定功能的类或接口，这些类或接口通常封装成为一个jar包， 直接放置于自己项目的lib目录下就可以使用，这些jar包就称为第三方组件。 SmartUpload.jar是从网络上下载的一个第三方组件，使用前只需将其复制到web项目的lib目录下即可 SmartUpload组件-File类    这个类封装了一个上传文件的所有信息。通过它，可以得到上传文件的文件名、文件大小、扩展名、文件数据等信息。主要方法有：</code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">saveAs</span><span class="params">(String)</span></span></span><br><span class="line"><span class="function"><span class="comment">//将文件换名另存。参数是以/开头的文件路径，文件将被存放于当前项目的根目录下</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getFieldName</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="comment">//获取HTML表单中此上传文件的组件的名字</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getFileName</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="comment">//获取上传的“文件名.扩展名”</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getFilePathName</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="comment">//获取上传的文件全名称(带路径)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getFileExt</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="comment">//获取文件的扩展名</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getSize</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="comment">//获取文件长度，单位字节</span></span></span><br><span class="line"><span class="function">   <span class="comment">//   这个类表示所有上传文件的集合，通过它可以得到上传文件的数目、大小等信息。其中的主要方法有：        </span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getCount</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="comment">//获取此次文件上传的总数目</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> File <span class="title">getFile</span><span class="params">(<span class="keyword">int</span>)</span></span></span><br><span class="line"><span class="function"><span class="comment">//获取指定索引处的文件</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getSize</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="comment">//获取此次文件上传的总字节数</span></span></span><br><span class="line"><span class="function">      <span class="comment">//  SmartUpload组件-Request类</span></span></span><br></pre></td></tr></table></figure><pre><code>这个类的功能等同于JSP内置的对象request。之所以提供这个类，是因为对于文件上传表单，通过JSP内置的request对象无法获得表单项的值，必须通过jspSmartUpload组件提供的Request对象来获取。其主要方法有 ：  </code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">initialize</span><span class="params">(PageContext)</span></span></span><br><span class="line"><span class="function"><span class="comment">//初始化方法</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">upload</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="comment">//文件上传。并检测文件大小和文件类型是否符合要求</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAllowedFilesList</span><span class="params">(String)</span></span></span><br><span class="line"><span class="function"><span class="comment">//设置允许上传的文件类型，参数可以使用“,”号隔开</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMaxFileSize</span><span class="params">(<span class="keyword">long</span>)</span></span></span><br><span class="line"><span class="function"><span class="comment">//设置每个文件允许的最大字节数</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setTotalMaxFileSize</span><span class="params">(<span class="keyword">long</span>)</span></span></span><br><span class="line"><span class="function"><span class="comment">//设置允许上传的文件总字节数</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Request <span class="title">getRequest</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="comment">//取得Request对象，用于取得表单组件的值</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setDeniedFilesList</span><span class="params">(String)</span></span></span><br><span class="line"><span class="function"><span class="comment">//限制那些类型的文件不允许上传。参数是文件的扩展名列表，可以使用“，”号隔开</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setContentDisposition</span><span class="params">(<span class="keyword">null</span>)</span></span></span><br><span class="line"><span class="function"><span class="comment">//在下载前调用。若不设定，下载的文件如果是doc文档，浏览器将调用word打开，如果是pdf文档，浏览器将调用Acrobat打开 </span></span></span><br><span class="line"><span class="function">     文件上传-页面设计</span></span><br></pre></td></tr></table></figure><pre><code>  以下案例使用Servlet作为控制器，接收客户端的上传文件并保存在upload目录下。upload目录在执行前必须先创建。    上传文件的表单必须设置以下两个属性：        method=“post”：文件上传必须使用post，因为使用get能够传送的数据大小有限制(2K字节或255个字符)        enctype=“multipart/form-data”:表明当前表单提交的数据有多个部分组成文件上传-Servlet控制器    如果使用JSP作为文件上传处理器，SmartUpload类的实例化和初始化方式为：                      SmartUpload su = new SmartUpload();                su.initialize(pageContext);文件下载-文件列表页面           </code></pre><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;table width=<span class="number">300</span> cellspacing=<span class="number">0</span>&gt;            </span><br><span class="line">    &lt;%                    <span class="comment">//读取upload下所有文件列表准备下载                    File f=new File(request.getRealPath("/upload"));                    File[] fs=f.listFiles();               </span></span><br><span class="line">         <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;fs.length;i++)&#123;             </span><br><span class="line">                %&gt;            </span><br><span class="line">         &lt;tr&gt;             </span><br><span class="line">            &lt;td style=<span class="string">"text-align:left;"</span>&gt;    </span><br><span class="line">                &lt;a href="download?fname=&lt;%=fs[i].getName()%&gt;"&gt;       &lt;%=fs[i].getName()%&gt; &lt;/a&gt;         </span><br><span class="line">            &lt;/td&gt;</span><br><span class="line">        &lt;/tr&gt;       </span><br><span class="line">    &lt;%&#125; %&gt;         </span><br><span class="line">   &lt;/table&gt;</span><br></pre></td></tr></table></figure><pre><code>文件下载-Servlet控制器    点击某个文件链接后跳转到Servlet访问地址download中，同时将文件名也发送过去。    运行前注意将server.xml中的&lt;Connector&gt;元素加入属性URIEncoding=&quot;gbk&quot;，和页面编码一致。使用SmartUpload注意事项    注意：如果使用JSP页面替代DownloadFile.java文件的话，在Java脚本范围外(即&lt;% ... %&gt;之外)，    不要包含HTML代码、空格、回车或换行等字符，有的话将不能正确下载。因为它影响了返回给浏览器的数据流，导致解析出错 </code></pre><p>参考<a href="https://blog.csdn.net/u012060033/article/details/82699668/" target="_blank" rel="noopener">https://blog.csdn.net/u012060033/article/details/82699668/</a></p>]]></content>
      
      
      <categories>
          
          <category> 网页 </category>
          
          <category> Jsp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Jsp分页 </tag>
            
            <tag> Jsp文件上传 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>jsp、servlet笔记</title>
      <link href="/2019/06/02/jsp-servlet%E7%AC%94%E8%AE%B0/"/>
      <url>/2019/06/02/jsp-servlet%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="jsp、servlet笔记"><a href="#jsp、servlet笔记" class="headerlink" title="jsp、servlet笔记"></a>jsp、servlet笔记</h1><p>1、init    初始化Jsp&amp;Servlet方法<br>   destroy 销毁Jsp&amp;Servlet之前的方法<br>   service 对用户请求生成响应的方法<br>2、Jsp文件必须在jsp服务器内运行<br>   Jsp文件必须生成servlet执行<br>   每个jsp页面的第一个访问者速度很慢，因为必须等待jsp编译为servlet<br>   jsp页面的访问者无需安装任何客户端，甚至不需要java的运行环境，因为jsp页面输送到客户端的是标准的html页面<br>3、jsp注释：&lt;%– 注释内容 –%&gt;<br>   html注释：<!-- 注释内容 --><br>   jsp声明：&lt;%!<br>声明部分<br>%&gt;<br>   jsp输出表达式：&lt;%= jsp表达式 %&gt;<br>4、通过jsp声明语法定义的变量和语法对应于servlet类里面的成员变量和方法,jsp脚本部分会转换为_jspService方法内的可执行代码，所以jsp脚本中不能定义方法，因为java不允许在方法内部定义方法<br>5、jsp三个编译指令：page 针对当前页面的指令<br>include 包含另一个页面（静态包含，会把被包含界面的编译指令也包含进来，但是动态的<a href="jsp:include" target="_blank" rel="noopener">jsp:include</a>不会）<br>taglib 用于定义和访问自定义标签<br>6、jsp的七个动作指令：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;jsp:forward page=<span class="string">""</span>&gt;</span><br><span class="line">&lt;jsp:param name=<span class="string">""</span> value=<span class="string">""</span>&gt;</span><br><span class="line">&lt;/jsp:forward&gt;  参数传递</span><br><span class="line">&lt;jsp:include&gt; 动态包含（仅导入页面body内容）</span><br><span class="line">&lt;jsp:plugin&gt; 用于下载javaBean或者Applet到客户端执行</span><br><span class="line">&lt;jsp:userBean&gt; 创建javaBean实例</span><br><span class="line">&lt;jsp:setProperty&gt; 设置javaBean实例的属性值</span><br><span class="line">&lt;jsp:getProperty&gt; 输出javaBean实例的属性值</span><br></pre></td></tr></table></figure><hr><p>ps: 执行forward时，用户请求的url不会发生改变，转发时客户端的请求参数不会丢失，但页面内容完全被forward目标页内容  所取代。相当于用新页面来生成或处理用户请求，所以请求参数、属性的信息不会丢失。<br>ps：静态导入和动态导入的区别：<br>1、静态导入是完全融合，两个页面融合为一个servlet；而动态导入则在servlet中使用include方法来引入被导入页面的b ody内容；<br>2、静态导入时被导入页面的编译指令会起作用，动态导入不会；</p><h2 id="3、动态包含可以追加额外参数；"><a href="#3、动态包含可以追加额外参数；" class="headerlink" title="3、动态包含可以追加额外参数；"></a>3、动态包含可以追加额外参数；</h2><p>7、jsp中的九个内置对象<br>application（让多个jsp、servlet共享数据）、config（可以获取servlet在web.xml文件中的配置参数——config.getInitParameter(“paramName”)）、exception、request、response、out（输出流对象，out.write(…)等价于&lt;%= jsp表达式 %&gt;）、session、page、pageContext</p><p>ps：四个map结构：page、request、session、application<br>8、在web.xml文件中配置application（servletContext实例）级别变量——在jsp中通过application.getInitParameter(“driver”)访问：</p><p>配置application级别变量：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;context-param&gt;</span><br><span class="line">&lt;param-name&gt;driver&lt;/param-name&gt;</span><br><span class="line">&lt;param-value&gt;com.mysql.jdbc.Driver&lt;/param-value&gt;</span><br><span class="line">&lt;/context-param&gt;</span><br></pre></td></tr></table></figure><p>配置servlet初始化参数：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;servlet&gt;</span><br><span class="line">&lt;init-param&gt;</span><br><span class="line">&lt;param-name&gt;name&lt;/param-name&gt;</span><br><span class="line">&lt;param-value&gt;jack&lt;/param-value&gt;</span><br><span class="line">&lt;/init-param&gt;</span><br><span class="line">&lt;/servlet&gt;</span><br></pre></td></tr></table></figure><p>9、PageContext内置对象：<br>代表页面上下文，用于访问jsp之间的共享数据，使用PageContext可以访问page、request、session、application范围的变量<br>getAttribute(String name)<br>setAttribute(String name,int scope)，scope可以是如下四个值：PageContext.PAGE_SCOPE、PageContext.REQUEST_SCOPE、PageContext.SESSION_SCOPE、PageContext.APPLICATION_SCOPE</p><p>PageContext.getRequest、PageContext.getResponse、PageContext.getServletConfig、<br>PageContext.getServletContext、PageContext.getSession</p><p>10、request对象：</p><h2 id="获取请求头、请求参数；操作request范围的属性；"><a href="#获取请求头、请求参数；操作request范围的属性；" class="headerlink" title="获取请求头、请求参数；操作request范围的属性；"></a>获取请求头、请求参数；操作request范围的属性；</h2><p>执行forward或者include——代替jsp提供的forward或者include指令。<br>HttpServletRequest类提供了一个getRequestDiapatcher(String path)（Path必须以”/开始”）方法，<br>其中path就是希望forward或include的目标路径，该方法返回RequestDispatcher对象。该对象提供以下两个方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-&gt; forward(ServletRequest request,ServletResponse response); <span class="comment">//forward到path下页面</span></span><br><span class="line">-&gt; include(ServletRequest request,ServletResponse response); <span class="comment">//将path页面include到本页面</span></span><br></pre></td></tr></table></figure><hr><p>11、response对象：<br>生成非字符响应（jsp的out对象属于JspWritter类，属于字符流的形式），对于字节流输出可以使用response<br>重定向：response.sendRedirect(“”)<br>增加cookie：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;%</span><br><span class="line">String name = request.getParameter(<span class="string">"name"</span>);</span><br><span class="line">Cookie cookie = <span class="keyword">new</span> Cookie(<span class="string">"userName"</span>,name);</span><br><span class="line">cookie.setMaxAge(<span class="number">24</span> * <span class="number">3600</span>);<span class="comment">//设置cookie有效期为24h，如果不设置，则web应用关闭时cookie自动失效</span></span><br><span class="line">response.addCookie(cookie);</span><br><span class="line">%&gt;</span><br><span class="line">&lt;%-- 获取本站保留的用户cookie --%&gt;</span><br><span class="line">&lt;%</span><br><span class="line">Cookie[] cookies = request.getCookies();</span><br><span class="line"><span class="keyword">for</span>(Cookie c: cookies)&#123;             <span class="comment">//遍历cookie查找输出</span></span><br><span class="line"><span class="keyword">if</span>(c.getName().equals(<span class="string">"userName"</span>))&#123;</span><br><span class="line">out.println(c.getValue());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">%&gt;</span><br></pre></td></tr></table></figure><p>如果cookie中出现中文字符，则必须使用java.net.URLEncoder进行编码，然后使用java.net.URLDecoder对其进行解码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;%</span><br><span class="line"><span class="comment">//使用java.net.URLEncoder.encode进行编码</span></span><br><span class="line">Cookie c = <span class="keyword">new</span> Cookie(<span class="string">"cnName"</span>,java.net.URLEncoder.encode(<span class="string">"梓煜"</span>),<span class="string">"GBK"</span>);</span><br><span class="line">cookie.setMaxAge(<span class="number">24</span> * <span class="number">3600</span>);<span class="comment">//设置cookie有效期为24h，如果不设置，则web应用关闭时cookie自动失效</span></span><br><span class="line">response.addCookie(cookie);</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取cookie</span></span><br><span class="line">Cookie[] cookies = request.getCookies();</span><br><span class="line"><span class="keyword">for</span>(Cookie c: cookies)&#123;             <span class="comment">//遍历cookie查找输出</span></span><br><span class="line"><span class="keyword">if</span>(c.getName().equals(<span class="string">"userName"</span>))&#123;</span><br><span class="line"><span class="comment">//使用java.net.URLDecoder.decode进行解码</span></span><br><span class="line">out.println(java.net.URLDecoder.decode(c.getValue()));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">%&gt;</span><br></pre></td></tr></table></figure><p>12、session对象：主要用于跟踪用户会话信息，如判断用户是否登录系统，或者在购物车应用中，用于跟踪用户购买的商品。<br>session范围的属性可以是多个页面的跳转之间共享，主要有setAttribute(String attName,Object attValue)、<br>getAttribute(String attName)两个常用方法。<br>session机制通常用于保存客户端的状态信息，这些状态信息需要保存到web服务器的硬盘上，所以要求session里的属性值必须是可序列化的，否则会引发不可序列化的异常。session的属性值可以是任何可序列化的java对象。<br>13、servlet介绍<br>servlet通常是服务端小程序，运行在服务器端，用于处理及响应客户端请求。<br>servlet是个特殊的java类，这个类必须继承HttpServlet，servlet提供不同的方法来响应客户端请求：<br>doGet、doPost、doPut、doDelete分别用于响应各自请求。一般只有doGet、doPost两种。<br>大部分时候，servlet对于所有请求的响应都是一样的，此时，可以重写service()方法即可响应客户端的所有响应。<br>另外HttpServlet包含另外两个方法：<br>-&gt; init(ServletConfig config) //创建servlet实例时，调用该方法初始化该servlet资源<br>-&gt; destroy() //销毁servlet时，自动调用该方法回收资源<br>ps：普通servlet类里的service()方法的作用，完全等同于jsp生成servlet类的_jspService()方法。<br>14、servlet的配置<br>配置servlet有2种方式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-&gt; 在servlet类中使用<span class="meta">@WebServlet</span> Annotation配置</span><br><span class="line">-&gt; 在web.xml文件中配置</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;servlet&gt;</span><br><span class="line">&lt;servlet-name&gt;aa&lt;/servlet-name&gt;</span><br><span class="line">&lt;servlet-<span class="class"><span class="keyword">class</span>&gt;<span class="title">org</span>.<span class="title">Class</span>&lt;/<span class="title">servlet</span>-<span class="title">class</span>&gt;</span></span><br><span class="line"><span class="class">&lt;/<span class="title">servlet</span>&gt;</span></span><br><span class="line"><span class="class">&lt;<span class="title">servlet</span>-<span class="title">mapping</span>&gt;</span></span><br><span class="line"><span class="class">&lt;<span class="title">servlet</span>-<span class="title">name</span>&gt;<span class="title">aa</span>&lt;/<span class="title">servlet</span>-<span class="title">name</span>&gt;</span></span><br><span class="line"><span class="class">&lt;<span class="title">url</span>-<span class="title">pattern</span>&gt;/<span class="title">aa</span>&lt;/<span class="title">url</span>-<span class="title">pattern</span>&gt;</span></span><br><span class="line"><span class="class">&lt;/<span class="title">servlet</span>-<span class="title">mapping</span>&gt;</span></span><br></pre></td></tr></table></figure><p>15、servlet的生命周期（servlet的创建销毁等都是由web容器决定）<br>-&gt;创建servlet实例-&gt;init()-&gt;完成初始化-&gt;响应客户请求-&gt;destroy()-&gt;资源回收完成-&gt;实例被销毁</p><p>servlet创建有2个时机，用户请求之时、应用启动之时（通常用于某些后台服务的servlet，或者用于拦截请求的servlet）</p><p>load-on-startup:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-&gt;它的值必须是一个整数，表示servlet应该被载入的顺序</span><br><span class="line">-&gt;当值为0或者大于0时，表示在容器启动的时候就被加载并初始化</span><br><span class="line">-&gt;当值小于0或者没有指定时，表示该servlet被选择调用的时候才会去加载</span><br><span class="line">-&gt;正数的值越小，该servlet的优先级越高，应用启动就越先加载</span><br><span class="line">-&gt;当值相同时，容器会自主选择相应servlet的加载顺序</span><br></pre></td></tr></table></figure><p>16、Filter介绍<br>Filter可以认为是servlet的加强版，主要用于在request到达servlet之前进行预处理或者response到达客户端之前对response进行预处理操作。<br>Filter主要分类：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-&gt;日志Filter：只要用于记录用户每次的请求操作</span><br><span class="line">-&gt;用户授权的Filter：负责检查用户请求，过滤非法请求</span><br><span class="line">-&gt;负责解码的Filter：包括对非标准编码的请求解码</span><br><span class="line">-&gt;XSTL：能改变xml内容的XSTL Filter</span><br><span class="line">-&gt;一个Filter可以拦截多个用户请求，一个请求也可以被多个Filter拦截</span><br></pre></td></tr></table></figure><p>创建Filter只需要：<br>-&gt;创建Filter类<br>-&gt;在web.xml文件中配置filter<br>创建Filter必须实现的接口javax.servlet.Filter接口，该接口中定义了三个方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-&gt;init(FilterConfig config)  <span class="comment">//在config对象中可以获取该filter的一些初始化参数，获取方法同servlet</span></span><br><span class="line">-&gt;destory() <span class="comment">//完成对filter销毁前资源的回收</span></span><br><span class="line">-&gt;doFilter(HttpServletRequest request,HttpServletResponse response,FilterChain chain)  <span class="comment">//doFilter方法中的代码实际就是从多个servlet中的service()方法中抽调出来的通用代码，通过利用filter可以很好地实现代码复用。</span></span><br></pre></td></tr></table></figure><p>17、Listener类<br>创建listener步骤：<br>-&gt;创建listener实现类<br>-&gt;在web.xml文件中配置该listener<br>常见的web事件监听器接口有以下几种：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">-&gt;ServletContextListener，用于监听web应用的启动关闭，</span><br><span class="line">-&gt;ServletContextAttributeListener，用于监听ServletContext(application)范围内属性的改变</span><br><span class="line">-&gt;ServletRequestListener，用于监听用户请求</span><br><span class="line">-&gt;ServletRequestAttributeListener，用于监听ServletRequest(request)范围的属性的改变</span><br><span class="line">-&gt;HttpSessionListener，用于监听session的开始和结束</span><br><span class="line">-&gt;HttpSessionAttributeListener，用于监听HttpSession(session)范围内属性的改变</span><br></pre></td></tr></table></figure><p>1)ServletContextListener </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;context-param&gt;</span><br><span class="line">        &lt;param-name&gt;name&lt;/param-name&gt;</span><br><span class="line">        &lt;param-value&gt;value&lt;/param-value&gt;</span><br><span class="line">  &lt;/context-param&gt;</span><br><span class="line"></span><br><span class="line">-&gt;contextInitialized(ServletContextEvent sce)，启动web应用时调用</span><br><span class="line">-&gt;contextDestroyed(ServletContextEvent sce)，关闭web应用时调用</span><br></pre></td></tr></table></figure><p>配置Listener<br>在listener实现类上添加注解@WebListener即可，或者在web.xml根目录中配置：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;listener&gt;</span><br><span class="line">&lt;!-- 指定该listener的实现类 --&gt;</span><br><span class="line">&lt;listener-<span class="class"><span class="keyword">class</span>&gt;&lt;/<span class="title">listener</span>-<span class="title">class</span>&gt;</span></span><br><span class="line"><span class="class">&lt;/<span class="title">listener</span>&gt;</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="title">ServletContextAttributeListener</span></span></span><br><span class="line"><span class="class">-&gt;<span class="title">attributeAdded</span>(<span class="title">ServletContextAttributeEvent</span> <span class="title">event</span>)，将存入一个属性至<span class="title">application</span>调用</span></span><br><span class="line"><span class="class">-&gt;<span class="title">attributeRemoved</span>(<span class="title">ServletContextAttributeEvent</span> <span class="title">event</span>)，将一个属性从<span class="title">application</span>范围中删除时调用</span></span><br><span class="line"><span class="class">-&gt;<span class="title">attributeReplaced</span>(<span class="title">ServletContextAttributeEvent</span> <span class="title">event</span>)，将一个属性替换时调用</span></span><br></pre></td></tr></table></figure><p>2)ServletRequestListener和ServletRequestAttributeListener</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ServletRequestListener用于监听用户请求的到达，该接口的监听器需实现以下两个方法：</span><br><span class="line">-&gt;requestInitialized(ServletRequestEvent event)，用户请求到达、被初始化时调用</span><br><span class="line">-&gt;requestDestroyed(ServletRequestEvent event)，用户请求结束、被销毁时调用</span><br><span class="line">ServletRequestAttributeListener用于监听request范围内属性的变化，该接口下方法如下：</span><br><span class="line">-&gt;attributeAdded(ServletRequestAttributeEvent event)</span><br><span class="line">-&gt;attributeRemoved(ServletRequestAttributeEvent event)</span><br><span class="line">-&gt;attributeReplaced(ServletRequestAttributeEvent event)  <span class="comment">//event.getName() or getValue()获取属性名、值</span></span><br></pre></td></tr></table></figure><p>3)HttpSessionListener和HttpSessionAttributeListener</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">-&gt;sessionCreated(HttpSessionEvent event)，用户与服务器的会话开始、创建时触发该方法</span><br><span class="line">-&gt;sessionDestroyed(HttpSessionEvent event)，用户服务器的会话断开、销毁时调用</span><br><span class="line">HttpSessionAttributeListener用于监听session范围内属性的变化，该接口下方法如下：</span><br><span class="line">-&gt;attributeAdded(ServletRequestAttributeEvent event)</span><br><span class="line">-&gt;attributeRemoved(ServletRequestAttributeEvent event)</span><br><span class="line">-&gt;attributeReplaced(ServletRequestAttributeEvent event)</span><br></pre></td></tr></table></figure><p>18、表达式语言<br>${expression}<br>在jsp页面中使用表达是语言可以直接获取请求参数值、获取javabean的指定属性值、获取请求头、获取各种范围属性值。<br>表达式语言内置11种：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">-&gt;pageContext，同jsp内置对象中的PageContext对象</span><br><span class="line">-&gt;pageScrope，用于获取page范围的属性值</span><br><span class="line">-&gt;requestScrope，用于获取request范围的属性值</span><br><span class="line">-&gt;sessionScrope，用于获取session范围属性值</span><br><span class="line">-&gt;applicationScrope，用于获取application范围属性值</span><br><span class="line">-&gt;param，用于获取请求的参数值</span><br><span class="line">-&gt;paramValues，用于获取属性为数组的属性值</span><br><span class="line">-&gt;header，用于获取请求头的属性值</span><br><span class="line">-&gt;headerValues，用于获取请求头的属性值维数组的属性值</span><br><span class="line">-&gt;initParam，用于获取web应用的初始化参数，即&lt;context-param&gt;&lt;/context-param&gt;中的值</span><br><span class="line">-&gt;cookie，用于获取cookie值</span><br></pre></td></tr></table></figure><p>19、servlet 3.0的文件上传<br>表单文件form.jsp：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;form method=<span class="string">"post"</span> action=<span class="string">"upload"</span> enctype=<span class="string">"multipart/form-data"</span>&gt;</span><br><span class="line">文件名：&lt;input type="text" id="name" name="name" /&gt;&lt;/br&gt;</span><br><span class="line">选择文件：&lt;input type=<span class="string">"file"</span> id=<span class="string">"file"</span> name=<span class="string">"file"</span> /&gt;</span><br><span class="line">&lt;input type=<span class="string">"submit"</span> value=<span class="string">"上传"</span> /&gt;</span><br><span class="line">&lt;/form&gt;</span><br></pre></td></tr></table></figure><p>UploadServlet如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@WebServlet</span>(name=<span class="string">"upload"</span>,urlPatterns=&#123;<span class="string">"/upload"</span>&#125;)</span><br><span class="line"><span class="meta">@MultipartConfig</span>   <span class="comment">//该注解指定该servlet用于处理文件上传请求</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UploadServlet</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">service</span><span class="params">(HttpServletRequest request,HttpServletResponse response)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">response.setContentType(<span class="string">"text/html;charset=utf-8"</span>);</span><br><span class="line">PrintWriter pw = response.getWriter();</span><br><span class="line"><span class="comment">//获取普通请求参数</span></span><br><span class="line">String fileName = request.getParameter(<span class="string">"name"</span>);</span><br><span class="line"><span class="comment">//获取上传文件域</span></span><br><span class="line">Part part = request.getPart(<span class="string">"file"</span>);</span><br><span class="line">out.println(<span class="string">"上传文件类型："</span>+ part.getContentType());</span><br><span class="line">out.println(<span class="string">"上传文件大小："</span>+ part.getSize());</span><br><span class="line"><span class="comment">//获取该文件上传域的Header Name</span></span><br><span class="line">Collection&lt;String&gt; headerNames = part.getHeaderNames();</span><br><span class="line"><span class="keyword">for</span>(String headerName: headerNames)&#123;</span><br><span class="line">out.println(headerName + <span class="string">"---"</span> + part.getHeader(headerName));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//将上传的文件写入服务器uploadFiles文件夹下面</span></span><br><span class="line">part.write(getServletContext().getRealPath(<span class="string">"/uploadFiles"</span>) + <span class="string">"/"</span> fileName);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>转自<a href="https://cloud.tencent.com/developer/article/1007739/" target="_blank" rel="noopener">https://cloud.tencent.com/developer/article/1007739/</a></p>]]></content>
      
      
      <categories>
          
          <category> 网页 </category>
          
          <category> Jsp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> servlet处理 </tag>
            
            <tag> jsp接收和显示 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
